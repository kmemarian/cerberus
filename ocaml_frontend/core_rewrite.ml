[@@@warning "-32"]
(*Generated by Lem from frontend/model/core_rewrite.lem.*)
open Lem_pervasives

open Utils
open Core
open Lem_core_aux
open Ctype
(*import Symbol Mem Mem_aux Mem_common*)

(*import Pp*)

module Caux = Lem_core_aux

(*val pp_pexpr: pexpr -> string*)


(*
type rewriter = <|
  unit_rwter:                                                      expr unit;
  false_rwter:                                                     expr unit;
  const_rwter:       Mem.mem_value                              -> expr unit;
  list_rwter:        list (expr unit)                           -> expr unit;
  ctype_rwter:       ctype                                      -> expr unit;
  sym_rwter:         sym                                        -> expr unit;
  impl_rwter:        Implementation_.implementation_constant    -> expr unit;
  tuple_rwter:       list (expr unit)                           -> expr unit;
  not_rwter:         expr unit                                  -> expr unit;
  op_rwter:          binop -> expr unit -> expr unit            -> expr unit;
  call_rwter:        name -> list (expr unit)                   -> expr unit;
  output_rwter:      string                                     -> expr unit;
  undef_rwter:       Undefined.undefined_behaviour              -> expr unit;
  error_rwter:                                                     expr unit;
  skip_rwter:                                                      expr unit;
  let_rwter:         sym -> expr unit -> expr unit              -> expr unit;
  if_rwter:          expr unit -> expr unit -> expr unit        -> expr unit;
  proc_rwter:        name -> list (expr unit)                   -> expr unit;
  action_rwter:      paction unit                               -> expr unit;
  unseq_rwter:       list (expr unit)                           -> expr unit;
  wseq_rwter:        list (maybe sym) -> expr unit -> expr unit -> expr unit;
  sseq_rwter:        list (maybe sym) -> expr unit -> expr unit -> expr unit;
  aseq_rwter:        maybe sym -> action unit -> paction unit   -> expr unit;
  indet_rwter:       expr unit                                  -> expr unit;
  bound_rwter:       nat -> expr unit                           -> expr unit;
  save_rwter:        ksym -> list (sym * ctype) -> expr unit    -> expr unit;
  run_rwter:         ksym -> list (sym * expr unit)             -> expr unit;
  ret_rwter:         expr unit                                  -> expr unit;
  nd_rwter:          list (expr unit)                           -> expr unit;
  par_rwter:         list (expr unit)                           -> expr unit;
  wait_rwter:        Thread.thread_id                           -> expr unit;
  is_scalar_rwter:   expr unit                                  -> expr unit;
  is_integer_rwter:  expr unit                                  -> expr unit;
  is_signed_rwter:   expr unit                                  -> expr unit;
  is_unsigned_rwter: expr unit                                  -> expr unit;
|>


(* TODO: check if lem now translates properly partially applied ctors *)
val rwter_identity: rewriter
let rwter_identity = <|
  unit_rwter=        Eunit;
  false_rwter=       Efalse;
  const_rwter=       fun cst -> Econst cst;
  list_rwter=        fun pes -> Elist pes;
  ctype_rwter=       fun ty -> Ectype ty;
  sym_rwter=         fun a -> Esym a;
  impl_rwter=        fun impl -> Eimpl impl;
  tuple_rwter=       fun pes -> Etuple pes;
  not_rwter=         fun pe -> Enot pe;
  op_rwter=          fun bop e1 e2 -> Eop bop e1 e2;
  call_rwter=        fun nm pes -> Ecall nm pes;
  output_rwter=      fun str -> Eoutput str;
  undef_rwter=       fun ubs -> Eundef ubs;
  error_rwter=       Eerror;
  skip_rwter=        Eskip;
  let_rwter=         fun a pe1 e2 -> Elet a pe1 e2;
  if_rwter=          fun pe1 e2 e3 -> Eif pe1 e2 e3;
  proc_rwter=        fun nm pes -> Eproc () nm pes;
  action_rwter=      fun pact -> Eaction pact;
  unseq_rwter=       fun es -> Eunseq es;
  wseq_rwter=        fun _as e1 e2 -> Ewseq _as e1 e2;
  sseq_rwter=        fun _as e1 e2 -> Esseq _as e1 e2;
  bound_rwter=       fun n e -> Ebound n e;
  save_rwter=        fun k a_tys e -> Esave k a_tys e;
  run_rwter=         fun k a_es -> Erun () k a_es;
  ret_rwter=         fun pe -> Eret pe;
  nd_rwter=          fun es -> End es;
  par_rwter=         fun es -> Epar es;
  wait_rwter=        fun tid -> Ewait tid;
  is_scalar_rwter=   fun pe -> Eis_scalar pe;
  is_integer_rwter=  fun pe -> Eis_integer pe;
  is_signed_rwter=   fun pe -> Eis_signed pe;
  is_unsigned_rwter= fun pe -> Eis_unsigned pe
|>

type only_effectful_rewriter = <|
  skip_erwter:                                                 expr unit;
  let_erwter:    sym -> expr unit -> expr unit              -> expr unit;
  if_erwter:     expr unit -> expr unit -> expr unit        -> expr unit;
  proc_erwter:   name -> list (expr unit)                   -> expr unit;
  action_erwter: paction unit                               -> expr unit;
  unseq_erwter:  list (expr unit)                           -> expr unit;
  wseq_erwter:   list (maybe sym) -> expr unit -> expr unit -> expr unit;
  sseq_erwter:   list (maybe sym) -> expr unit -> expr unit -> expr unit;
  aseq_erwter:   maybe sym -> action unit -> paction unit   -> expr unit;
  indet_erwter:  expr unit                                  -> expr unit;
  bound_erwter:  nat -> expr unit                           -> expr unit;
  save_erwter:   ksym -> list (sym * ctype) -> expr unit    -> expr unit;
  run_erwter:    ksym -> list (sym * expr unit)             -> expr unit;
  ret_erwter:    expr unit                                  -> expr unit;
  nd_erwter:     list (expr unit)                           -> expr unit;
  par_erwter:    list (expr unit)                           -> expr unit;
  wait_erwter:   Thread.thread_id                           -> expr unit;
|>

val rwter_only_effectful: only_effectful_rewriter -> rewriter
let rwter_only_effectful r = <| rwter_identity with
  skip_rwter=   r.skip_erwter;
  let_rwter=    fun a pe1 e2 -> if is_pure e2 then Elet a pe1 e2 else r.let_erwter a pe1 e2;
  if_rwter=     fun pe1 e2 e3 -> if is_pure e2 && is_pure e3 then Eif pe1 e2 e3 else r.if_erwter pe1 e2 e3;
  proc_rwter=   r.proc_erwter;
  action_rwter= r.action_erwter;
  unseq_rwter=  r.unseq_erwter;
  wseq_rwter=   r.wseq_erwter;
  sseq_rwter=   r.sseq_erwter;
  aseq_rwter=   r.aseq_erwter;
  indet_rwter=  r.indet_erwter;
  bound_rwter=  r.bound_erwter;
  save_rwter=   r.save_erwter;
  run_rwter=    r.run_erwter;
  ret_rwter=    r.ret_erwter;
  nd_rwter=     r.nd_erwter;
  par_rwter=    r.par_erwter;
  wait_rwter=   r.wait_erwter
|>
*)









(* Removes unnecessary Eskip ctors using the following rewritings:

     let weak/strong pat = skip in e2      ===>    e2 [pat \ Vunit]
     let weak/strong pat = e1 in skip      ===>    e1               *)
let rec remove_skips ((Expr( annot1, expr_) as expr1)) =
   ((match expr_ with
    | Epure pe ->
        (* unchanged *)
        expr1
    | Ememop( _, _) ->
        (* unchanged *)
        expr1
    | Eaction _ ->
        (* unchanged *)
        expr1
    | Ecase( pe, pat_es) ->
        (* just traversing *)
        Expr( annot1, (Ecase( pe, (Lem_list.map (fun (pat, e) -> (pat, remove_skips e)) pat_es))))
    | Elet( pat, pe1, e2) ->
        (* just traversing *)
        Expr( annot1, (Elet( pat, pe1, (remove_skips e2))))
    | Eif( pe1, e2, e3) ->
        (* just traversing *)
        Expr( annot1, (Eif( pe1, (remove_skips e2), (remove_skips e3))))
    | Eccall( _, _, _, _) ->
        (* unchanged *)
        expr1
    | Eproc( _, _, _) ->
        (* unchanged *)
        expr1
    | Eunseq es ->
        (* just traversing *)
        Expr( annot1, (Eunseq (Lem_list.map remove_skips es)))
    | Ewseq( pat, e1, e2) ->
        (match remove_skips e1 with
          | Expr( _, (Epure (Pexpr( _, _, (PEval Vunit))))) ->
              remove_skips (Core_aux.unsafe_subst_pattern pat Core_aux.mk_unit_pe e2)
          | e1' ->
              (match remove_skips e2 with
                | (Expr( _, (Epure (Pexpr( _, _, (PEval Vunit)))))) ->
                    e1'
                | e2' ->
                    Expr( annot1, (Ewseq( pat, e1', e2')))
              )
        )
    | Esseq( pat, e1, e2) ->
        (match remove_skips e1 with
          | Expr( _, (Epure (Pexpr( _, _, (PEval Vunit))))) ->
              remove_skips (Core_aux.unsafe_subst_pattern pat Core_aux.mk_unit_pe e2)
          | e1' ->
              (match remove_skips e2 with
                | (Expr( _, (Epure (Pexpr( _, _, (PEval Vunit)))))) ->
                    e1'
                | e2' ->
                    Expr( annot1, (Esseq( pat, e1', e2')))
              )
        )
    | Ebound e ->
        (* just traversing *)
        Expr( annot1, (Ebound (remove_skips e)))
    | End es ->
        (* just traversing *)
        Expr( annot1, (End (Lem_list.map remove_skips es)))
    | Esave( sym_bTy, sym_bTy_pes, e) ->
        (* just traversing *)
        Expr( annot1, (Esave( sym_bTy, sym_bTy_pes, (remove_skips e))))
    | Erun( _, _, _) ->
        (* unchanged *)
        expr1
    | Epar es ->
        (* just traversing *)
        Expr( annot1, (Epar (Lem_list.map remove_skips es)))
    | Ewait _ ->
        (* unchanged *)
        expr1
    | Eannot( xs, e) ->
        (* just traversing *)
        Expr( annot1, (Eannot( xs, (remove_skips e))))
    | Eexcluded( _, _) ->
        (* unchanged *)
        expr1
  ))


let rec remove_unseqs ((Expr( annot1, expr_) as expr1)) =
   ((match expr_ with
    | Epure _ ->
        (* unchanged *)
        expr1
    | Ememop( _, _) ->
        (* unchanged *)
        expr1
    | Eaction _ ->
        (* unchanged *)
        expr1
    | Ecase( pe, pat_es) ->
        (* just traversing *)
        Expr( annot1, (Ecase( pe, (Lem_list.map (fun (pat, e) -> (pat, remove_unseqs e)) pat_es))))
    | Elet( pat, pe1, e2) ->
        (* just traversing *)
        Expr( annot1, (Elet( pat, pe1, (remove_unseqs e2))))
    | Eif( pe1, e2, e3) ->
        (* just traversing *)
        Expr( annot1, (Eif( pe1, (remove_unseqs e2), (remove_unseqs e3))))
    | Eccall( _, _, _, _) ->
        (* unchanged *)
        expr1
    | Eproc( _, _, _) ->
        (* unchanged *)
        expr1
    | Eunseq es ->
        let pes_opt = (List.fold_right (fun e acc_opt ->
          (match (acc_opt, Core_aux.to_pure e) with
            | (Some acc, Some pe) ->
                Some (pe :: acc)
            | _ ->
                None
          )) es (Some [])) in
        Expr( annot1, (Lem.option_case (Eunseq (Lem_list.map remove_unseqs es)) (fun pes -> Epure (Core_aux.mk_tuple_pe pes)) pes_opt))
(* TODO (bring back)
  | Ewseq pat (Eunseq es) e2 ->
      (* ys is the assoc list of symbolic names, values that can be substituted away *)
      let (rev_xs, rev_ys) = List.foldl (fun (acc1, acc2) (sym_opt, e) ->
        match to_pure e with
          | Just cval ->
              (acc1, (sym_opt, cval) :: acc2)
          | Nothing ->
              ((sym_opt, remove_unseqs e) :: acc1, acc2)
        end) ([], []) (List.zip pat es) in
      
      let e2' =
        remove_unseqs $ List.foldl (fun acc (sym_opt, cval) ->
          maybe acc (fun (sym, _) -> subst_sym sym cval acc) sym_opt
        ) e2 rev_ys in
      
      match rev_xs with
        | [] ->
            e2'
        | [(a_opt, e')] ->
            Ewseq [a_opt] e' e2'
        | _ ->
            let (_as', es') = List.unzip $ List.reverse rev_xs in
            Ewseq _as' (Eunseq es') e2'
      end
*)
(* TODO (bring back)
  | Esseq _as (Eunseq es) e2 ->
      let (rev_xs, rev_ys) = List.foldl (fun (acc1, acc2) (sym_opt, e) ->
        match to_pure e with
          | Just pe ->
              (acc1, (sym_opt, pe) :: acc2)
          | Nothing ->
              ((sym_opt, remove_unseqs e) :: acc1, acc2)
        end) ([], []) (List.zip _as es) in
      
      let e2' =
        remove_unseqs $ List.foldl (fun acc (sym_opt, pe) ->
          maybe acc (fun (sym, _) -> subst_sym sym pe acc) sym_opt
        ) e2 rev_ys in
      
      match rev_xs with
        | [] ->
            e2'
        | [(sym_opt, e')] ->
            Esseq [sym_opt] e' e2'
        | _ ->
            let (_as', es') = List.unzip $ List.reverse rev_xs in
            Esseq _as' (Eunseq es') e2'
      end
*)
    | Ewseq( pat, e1, e2) ->
        (* just traversing *)
        Expr( annot1, (Ewseq( pat, (remove_unseqs e1), (remove_unseqs e2))))
    | Esseq( pat, e1, e2) ->
        (* just traversing *)
        Expr( annot1, (Esseq( pat, (remove_unseqs e1), (remove_unseqs e2))))
    | Ebound e ->
        (* just traversing *)
        Expr( annot1, (Ebound (remove_unseqs e)))
    | End es ->
        (* just traversing *)
        Expr( annot1, (End (Lem_list.map remove_unseqs es)))
    | Esave( sym_bTy, sym_bTy_pes, e) ->
        (* just traversing *)
        Expr( annot1, (Esave( sym_bTy, sym_bTy_pes, (remove_unseqs e))))
    | Erun( _, _, _) ->
        (* unchanged *)
        expr1
    | Epar es ->
        (* just traversing *)
        Expr( annot1, (Epar (Lem_list.map remove_unseqs es)))
    | Ewait _ ->
        (* unchanged *)
        expr1
    | Eannot( xs, e) ->
        (* just traversing *)
        Expr( annot1, (Eannot( xs, (remove_unseqs e))))
    | Eexcluded( _, _) ->
        (* unchanged *)
        expr1
  ))


(*
let rec remove_seqs expr =
  match expr with
  | Elet pat e1 e2 ->
      Elet pat e1 (remove_seqs e2)

  | Eif pe1 e2 e3 ->
      Eif pe1 (remove_seqs e2) (remove_seqs e3)

  | Eunseq es ->
      Eunseq (List.map remove_seqs es)
  
  | Ewseq _as e1 e2 ->
      let e1' = remove_seqs e1 in
      let e2' = remove_seqs e2 in
      match _as with
        | [Just a] ->
            if is_pure e1' then
              subst_sym a e1' e2'
            else
              Ewseq _as e1' e2'
        | _ ->
            if is_value e1' then
              subst_syms _as e1' e2'
            else
              Ewseq _as e1' e2'
      end
  
  | Esseq _as e1 e2 ->
      let e1' = remove_seqs e1 in
      let e2' = remove_seqs e2 in
      match _as with
        | [Just a] ->
            if is_pure e1' then
              subst_sym a e1' e2'
            else
              Esseq _as e1' e2'
        | _ ->
            if is_value e1' then
              subst_syms _as e1' e2'
            else
              Esseq _as e1' e2'
      end
  
(*
  | Etry e str_es ->
      Etry (remove_seqs e) (List.map (fun (str, e) -> (str, remove_seqs e)) str_es)
*)
  | Ebound e ->
      Ebound (remove_seqs e)
  | Esave k sym_tys e ->
      Esave k sym_tys (remove_seqs e)
  | End es ->
      End (List.map remove_seqs es)
  | Epar es ->
      Epar (List.map remove_seqs es)
  | _ ->
      expr
  end
*)


(* returns a Right iff the expression always ends with a return() *)
(*val extract_either: forall 'a. either 'a 'a -> 'a*)
let extract_either:('a,'a)Either.either ->'a=  ((function
  | Either.Left z ->
      z
  | Either.Right z ->
      z
))

let rec remove_dead_aux ((Expr( annot1, expr_) as expr1)) =
   ((match expr_ with
    | Epure _ ->
        Either.Left expr1
    | Ememop( _, _) ->
        Either.Left expr1
    | Eaction _ ->
        Either.Left expr1
    | Ecase( pe, pat_es) ->
        let aux (pat, e)=
           (Either.either_case
            (fun e' -> Either.Left (pat, e'))
            (fun e' -> Either.Right (pat, e'))
            (remove_dead_aux e)) in
        let _rev_pat_es' = (List.fold_left (fun _acc _pat_e' ->
          (match (_pat_e', _acc) with
            | (Either.Right pat_e', Either.Right acc) ->
                Either.Right (pat_e' :: acc)
            | _ ->
                Either.Left ((extract_either _pat_e') :: (extract_either _acc))
          )
        ) (Either.Right []) (Lem_list.map aux pat_es)) in
        (match _rev_pat_es' with
          | Either.Left rev_pat_es' ->
              Either.Left (Expr( annot1, (Ecase( pe, (List.rev rev_pat_es')))))
          | Either.Right rev_pat_es' ->
              Either.Right (Expr( annot1, (Ecase( pe, (List.rev rev_pat_es')))))
        )
    | Elet( pat, pe1, e2) ->
        (match remove_dead_aux e2 with
          | Either.Left e2' ->
              Either.Left (Expr( annot1, (Elet( pat, pe1, e2'))))
          | Either.Right e2' ->
              Either.Right (Expr( annot1, (Elet( pat, pe1, e2'))))
        )
    | Eif( pe1, e2, e3) ->
        (match (remove_dead_aux e2, remove_dead_aux e3) with
          | (Either.Right e2', Either.Right e3') ->
              Either.Right (Expr( annot1, (Eif( pe1, e2', e3'))))
          | (Either.Left e2', Either.Right e3') ->
              Either.Left (Expr( annot1, (Eif( pe1, e2', e3'))))
          | (Either.Right e2', Either.Left e3') ->
              Either.Left (Expr( annot1, (Eif( pe1, e2', e3'))))
          | (Either.Left e2', Either.Left e3') ->
              Either.Left (Expr( annot1, (Eif( pe1, e2', e3'))))
        )
    | Eccall( _, _, _, _) ->
        Either.Left expr1
    | Eproc( _, _, _) ->
        Either.Left expr1
    | Eunseq es ->
        let _es' = (Lem_list.map remove_dead_aux es) in
        (* TODO: this is inefficient (but readable) see Ecase, End, Epar for the
           unreadable but efficient alternative. We should rewrite some
           combinator for either *)
        if List.for_all ((function
  | Either.Right _ -> true
  | Either.Left _ -> false
)) _es' then
          Either.Right (Expr( annot1, (Eunseq (Lem_list.map extract_either _es'))))
        else
          Either.Left (Expr( annot1, (Eunseq (Lem_list.map extract_either _es'))))
    | Ewseq( _as, e1, e2) ->
        (match remove_dead_aux e1 with
          | Either.Left e1' ->
              (match remove_dead_aux e2 with
                | Either.Left e2' ->
                    Either.Left (Expr( annot1, (Ewseq( _as, e1', e2'))))
                | Either.Right e2' ->
                    Either.Right (Expr( annot1, (Ewseq( _as, e1', e2'))))
              )
          | Either.Right e1' ->
              Either.Right e1'
        )
    | Esseq( _as, e1, e2) ->
        (match remove_dead_aux e1 with
          | Either.Left e1' ->
              (match remove_dead_aux e2 with
                | Either.Left e2' ->
                    Either.Left (Expr( annot1, (Esseq( _as, e1', e2'))))
                | Either.Right e2' ->
                    Either.Right (Expr( annot1, (Esseq( _as, e1', e2'))))
              )
          | Either.Right e1' ->
              Either.Right e1'
        )
    | Ebound e ->
        (match remove_dead_aux e with
          | Either.Left e' ->
              Either.Left (Expr( annot1, (Ebound e')))
          | Either.Right e' ->
              Either.Right (Expr( annot1, (Ebound e')))
        )
    | End es ->
        let _rev_es' = (List.fold_left (fun _acc _e' ->
          (match (_e', _acc) with
            | (Either.Right e', Either.Right acc) ->
                Either.Right (e' :: acc)
            | _ ->
                Either.Left ((extract_either _e') :: (extract_either _acc))
          )
        ) (Either.Right []) (Lem_list.map remove_dead_aux es)) in
        (match _rev_es' with
          | Either.Left rev_es' ->
              Either.Left (Expr( annot1, (End (List.rev rev_es'))))
          | Either.Right rev_es' ->
              Either.Right (Expr( annot1, (End (List.rev rev_es'))))
        )
    | Esave( sym_bTy, sym_bTy_pes, e) ->
        (match remove_dead_aux e with
          | Either.Left e' ->
              Either.Left (Expr( annot1, (Esave( sym_bTy, sym_bTy_pes, e'))))
          | Either.Right e' ->
              Either.Right (Expr( annot1, (Esave( sym_bTy, sym_bTy_pes, e'))))
        )
    | Erun( _, _, _) ->
        Either.Left expr1
    | Epar es ->
        let _rev_es' = (List.fold_left (fun _acc _e' ->
          (match (_e', _acc) with
            | (Either.Right e', Either.Right acc) ->
                Either.Right (e' :: acc)
            | _ ->
                Either.Left ((extract_either _e') :: (extract_either _acc))
          )
        ) (Either.Right []) (Lem_list.map remove_dead_aux es)) in
        (match _rev_es' with
          | Either.Left rev_es' ->
              Either.Left (Expr( annot1, (Epar (List.rev rev_es'))))
          | Either.Right rev_es' ->
              Either.Right (Expr( annot1, (Epar (List.rev rev_es'))))
        )
    | Ewait _ ->
        Either.Left expr1
    | Eannot( xs, e) ->
        (match remove_dead_aux e with
          | Either.Left e' ->
              Either.Left (Expr( annot1, (Eannot( xs, e'))))
          | Either.Right e' ->
              Either.Right (Expr( annot1, (Eannot( xs, e'))))
        )
    | Eexcluded( _, _) ->
        Either.Left expr1
  ))

let remove_dead expr1 =
   ((match remove_dead_aux expr1 with
    | Either.Left expr' ->
        expr'
    | Either.Right expr' ->
        expr'
  ))


let rec flatten_seqs ((Expr( annot1, expr_) as expr1)) =
   ((match expr_ with
    | Epure _ ->
        expr1
    | Ememop( _, _) ->
        expr1
    | Eaction _ ->
        expr1
    | Ecase( pe, pat_es) ->
        Expr( annot1, (Ecase( pe, (Lem_list.map (fun (pat, e) -> (pat, flatten_seqs e)) pat_es))))
    | Elet( pat, pe1, e2) ->
        Expr( annot1, (Elet( pat, pe1, (flatten_seqs e2))))
    | Eif( pe1, e2, e3) ->
        Expr( annot1, (Eif( pe1, (flatten_seqs e2), (flatten_seqs e3))))
    | Eccall( _, _, _, _) ->
        expr1
    | Eproc( _, _, _) ->
        expr1
    | Eunseq es ->
        Expr( annot1, (Eunseq (Lem_list.map flatten_seqs es)))
    | Ewseq( (Pattern( _, (CaseBase (None, _)))), (Expr( _, (Epure (Pexpr( _, _, (PEval Vunit)))))), e2) ->
        (* TODO: could be generalised to any "always defined" Epure *)
        flatten_seqs e2
    | Ewseq( pat, e1, e2) ->
        (match (flatten_seqs e1, flatten_seqs e2) with
          | (Expr( annot11, (Ewseq( pat1, e11, e12))), e2') ->
              Expr( annot11, (Ewseq( pat1, e11, (flatten_seqs (Expr( annot1, (Ewseq( pat, e12, e2'))))))))
(*
          | (Expr annot1 (Esseq pat1 e11 e12), e2') ->
              Expr annot1 (Esseq pat1 e11 (flatten_seqs (Expr annot (Ewseq pat e12 e2'))))
*)
          | (e1', e2') ->
              Expr( annot1, (Ewseq( pat, e1', e2')))
        )
    | Esseq( (Pattern( _, (CaseBase (None, _)))), (Expr( _, (Epure (Pexpr( _, _, (PEval Vunit)))))), e2) ->
        (* TODO: could be generalised to any "always defined" Epure *)
        flatten_seqs e2
    | Esseq( pat, e1, e2) ->
        (match (flatten_seqs e1, flatten_seqs e2) with
(* THIS IS WRONG, shouldn't lift a wseq past a sseq
          | (Expr annot1 (Ewseq pat1 e11 e12), e2') ->
              Expr annot1 (Ewseq pat1 e11 (flatten_seqs (Expr annot (Esseq pat e12 e2'))))
*)
          | (Expr( annot11, (Esseq( pat1, e11, e12))), e2') ->
              Expr( annot11, (Esseq( pat1, e11, (flatten_seqs (Expr( annot1, (Esseq( pat, e12, e2'))))))))
          | (e1', e2') ->
              Expr( annot1, (Esseq( pat, e1', e2')))
        )
    | Ebound e ->
        Expr( annot1, (Ebound (flatten_seqs e)))
    | End es ->
        Expr( annot1, (End (Lem_list.map flatten_seqs es)))
    | Esave( sym1, sym_bTys, e) ->
        Expr( annot1, (Esave( sym1, sym_bTys, (flatten_seqs e))))
    | Erun( _, _, _) ->
        expr1
    | Epar es ->
        Expr( annot1, (Epar (Lem_list.map flatten_seqs es)))
    | Ewait _ ->
        expr1
    | Eannot( xs, e) ->
        Expr( annot1, (Eannot( xs, (flatten_seqs e))))
    | Eexcluded( _, _) ->
        expr1
  ))


(* TODO: very quick'n'dirty *)
(* remove call to conv_int obviously not doing anything (using รยง5.2.4.2.1) *)
(*val in_minimal_range: ctype -> integer -> bool*)
let in_minimal_range (Ctype( _, ty1)) n:bool=
   ((match ty1 with
    | Basic (Ctype.Integer Ctype.Char) ->
        false (* TODO: because we don't use char is signed or unsigned *)
    | Basic (Ctype.Integer Ctype.Bool) -> Nat_big_num.equal
        n( (Nat_big_num.of_int 0)) && Nat_big_num.equal n( (Nat_big_num.of_int 1))
    | Basic (Ctype.Integer (Ctype.Signed Ctype.Ichar)) -> Nat_big_num.less_equal
        (Nat_big_num.sub( (Nat_big_num.of_int 0))( (Nat_big_num.of_int 127))) n && Nat_big_num.less_equal n( (Nat_big_num.of_int 127))
    | Basic (Ctype.Integer (Ctype.Signed Ctype.Short)) -> Nat_big_num.less_equal
        (Nat_big_num.sub( (Nat_big_num.of_int 0))( (Nat_big_num.of_int 32767))) n && Nat_big_num.less_equal n( (Nat_big_num.of_int 32767))
    | Basic (Ctype.Integer (Ctype.Signed Ctype.Int_)) -> Nat_big_num.less_equal
        (Nat_big_num.sub( (Nat_big_num.of_int 0))( (Nat_big_num.of_int 32767))) n && Nat_big_num.less_equal n( (Nat_big_num.of_int 32767))
    | Basic (Ctype.Integer (Ctype.Signed Ctype.Long)) -> Nat_big_num.less_equal
        (Nat_big_num.sub( (Nat_big_num.of_int 0))( (Nat_big_num.of_string "2147483647"))) n && Nat_big_num.less_equal n( (Nat_big_num.of_string "2147483647"))
    | Basic (Ctype.Integer (Ctype.Signed Ctype.LongLong)) ->
        let k = (Nat_big_num.sub (Nat_big_num.pow_int( (Nat_big_num.of_int 2)) 63)( (Nat_big_num.of_int 1))) in Nat_big_num.less_equal
        (Nat_big_num.negate k) n && Nat_big_num.less_equal n k
    | Basic (Ctype.Integer (Ctype.Unsigned Ctype.Ichar)) -> Nat_big_num.less_equal( (Nat_big_num.of_int 0)) n && Nat_big_num.less_equal n( (Nat_big_num.of_int 255))
    | Basic (Ctype.Integer (Ctype.Unsigned Ctype.Short)) -> Nat_big_num.less_equal( (Nat_big_num.of_int 0)) n && Nat_big_num.less_equal n( (Nat_big_num.of_int 65535))
    | Basic (Ctype.Integer (Ctype.Unsigned Ctype.Int_)) -> Nat_big_num.less_equal( (Nat_big_num.of_int 0)) n && Nat_big_num.less_equal n( (Nat_big_num.of_int 65535))
    | Basic (Ctype.Integer (Ctype.Unsigned Ctype.Long)) -> Nat_big_num.less_equal( (Nat_big_num.of_int 0)) n && Nat_big_num.less_equal n( (Nat_big_num.of_string "4294967295"))
    | Basic (Ctype.Integer (Ctype.Unsigned Ctype.LongLong)) ->
        let k = (Nat_big_num.sub (Nat_big_num.pow_int( (Nat_big_num.of_int 2)) 64)( (Nat_big_num.of_int 1))) in Nat_big_num.less_equal( (Nat_big_num.of_int 0)) n && Nat_big_num.less_equal n k
    | _ ->
        false (* others are impl-def are should be given at conv_int as argument *)
  ))


(*val     remove_conv_int_pexpr: pexpr -> pexpr*)
let rec remove_conv_int_pexpr (Pexpr( annot1, bTy, _pe)) =
   (Pexpr( annot1, bTy, (match _pe with
    | PEsym _ ->
        _pe
    | PEimpl _ ->
        _pe
    | PEval _ ->
        _pe
    | PEundef( _, _) ->
        _pe
    | PEerror( str, pe) ->
        PEerror( str, (remove_conv_int_pexpr pe))
    | PEctor( ctor1, pes) ->
        PEctor( ctor1, (Lem_list.map remove_conv_int_pexpr pes))
    | PEcase( pe, pat_pes) ->
        PEcase( (remove_conv_int_pexpr pe), begin
          Lem_list.map (fun (pat, pe) ->
            (pat, remove_conv_int_pexpr pe)
          ) pat_pes
        end)
    | PEarray_shift( pe1, ty1, pe2) ->
        PEarray_shift( (remove_conv_int_pexpr pe1), ty1, (remove_conv_int_pexpr pe2))
    | PEmember_shift( pe, tag_sym, memb_ident) ->
        PEmember_shift( (remove_conv_int_pexpr pe), tag_sym, memb_ident)
    | PEmemop( mop, pes) ->
        PEmemop( mop, (Lem_list.map remove_conv_int_pexpr pes))
    | PEnot pe ->
        PEnot (remove_conv_int_pexpr pe)
    | PEop( bop, pe1, pe2) ->
        PEop( bop, (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2))
    | PEconv_int( ity, pe) ->
        PEconv_int( ity, (remove_conv_int_pexpr pe))
    | PEwrapI( ity, iop1, pe1, pe2) ->
        PEwrapI( ity, iop1, (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2))
    | PEcatch_exceptional_condition( ity, iop1, pe1, pe2) ->
        PEcatch_exceptional_condition( ity, iop1, (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2))
    | PEstruct( sym1, ident_pes) ->
        PEstruct( sym1, (Lem_list.map (fun (ident, pe) -> (ident, remove_conv_int_pexpr pe)) ident_pes))
    | PEunion( sym1, ident, pe) ->
        PEunion( sym1, ident, (remove_conv_int_pexpr pe))
    | PEcfunction pe ->
        PEcfunction (remove_conv_int_pexpr pe)
    | PEmemberof( tag_sym, memb_ident, pe) ->
        PEmemberof( tag_sym, memb_ident, (remove_conv_int_pexpr pe))
    | PEcall( nm, pes) ->
        let pes' = (Lem_list.map remove_conv_int_pexpr pes) in
        (match (nm, pes') with
          (* TODO: hack !!!!!!!!! *)
          | (Sym (Symbol.Symbol( _, _, (Symbol.SD_Id "conv_int"))), [pe_ty; pe_n]) ->
              (match (Core_aux.valueFromPexpr pe_ty, Core_aux.valueFromPexpr pe_n) with
                | (Some (Vctype ty1), Some (((Vobject (OVinteger ival)) as cval))) ->
                    (match Mem_aux.integerFromIntegerValue ival with
                      | Some n ->
                          if in_minimal_range ty1 n then
                            PEval cval
                          else
                            PEcall( nm, pes')
                      | None ->
                          PEcall( nm, pes')
                    )
                | _ ->
                    PEcall( nm, pes')
(*                    assert_false ("remove_conv_int_pexpr: Core type error? ==> " ^ pp_pexpr pexpr ^ " <==> " ^ pp_pexpr (PEval cval)) *)
              )
          | (Sym (Symbol.Symbol( _, _, (Symbol.SD_Id "conv"))), [pe_ty1; pe_ty2; Pexpr( _, _, _pe_n)]) ->
              if pe_ty1 = pe_ty2 then
                _pe_n
              else
                PEcall( nm, pes')
          | _ ->
              PEcall( nm, pes')
        )
    | PElet( pat, pe1, pe2) ->
        PElet( pat, (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2))
    | PEif( pe1, pe2, pe3) ->
        PEif( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), (remove_conv_int_pexpr pe3))
    | PEis_scalar pe ->
        PEis_scalar (remove_conv_int_pexpr pe)
    | PEis_integer pe ->
        PEis_integer (remove_conv_int_pexpr pe)
    | PEis_signed pe ->
        PEis_signed (remove_conv_int_pexpr pe)
    | PEis_unsigned pe ->
        PEis_unsigned (remove_conv_int_pexpr pe)
    | PEbmc_assume pe ->
        PEbmc_assume (remove_conv_int_pexpr pe)
    | PEare_compatible( pe1, pe2) ->
        PEare_compatible( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2))
  )))

let rec remove_conv_int (Expr( annot1, expr_)) =
   (Expr( annot1, (match expr_ with
    | Epure pe ->
        Epure (remove_conv_int_pexpr pe)
    | Ememop( memop1, pes) ->
        Ememop( memop1, (Lem_list.map remove_conv_int_pexpr pes))
    | Eaction pact ->
        Eaction (remove_conv_int_paction pact)
    | Ecase( pe, pat_es) ->
        Ecase( (remove_conv_int_pexpr pe), begin
          Lem_list.map (fun (pat, e) ->
            (pat, remove_conv_int e)
          ) pat_es
        end)
    | Elet( pat, pe1, e2) ->
        Elet( pat, (remove_conv_int_pexpr pe1), (remove_conv_int e2))
    | Eif( pe1, e2, e3) ->
        Eif( (remove_conv_int_pexpr pe1), (remove_conv_int e2), (remove_conv_int e3))
    | Eccall( (), ty1, pe, pes) ->
        Eccall( (), (remove_conv_int_pexpr ty1), (remove_conv_int_pexpr pe), (Lem_list.map remove_conv_int_pexpr pes))
    | Eproc( (), nm, pes) ->
        Eproc( (), nm, (Lem_list.map remove_conv_int_pexpr pes))
    | Eunseq es ->
        Eunseq (Lem_list.map remove_conv_int es)
    | Ewseq( pat, e1, e2) ->
        Ewseq( pat, (remove_conv_int e1), (remove_conv_int e2))
    | Esseq( pat, e1, e2) ->
        Esseq( pat, (remove_conv_int e1), (remove_conv_int e2))
    | Ebound e ->
        Ebound (remove_conv_int e)
    | End es ->
        End (Lem_list.map remove_conv_int es)
    | Esave( sym_bTy, sym_bTy_pes, e) ->
        Esave( sym_bTy, begin
          Lem_list.map (fun (sym1, (bTy, pe)) ->
            (sym1, (bTy, remove_conv_int_pexpr pe))
          ) sym_bTy_pes
        end, (remove_conv_int e))
    | Erun( annot1, sym1, pes) ->
        Erun( annot1, sym1, (Lem_list.map remove_conv_int_pexpr pes))
    | Epar es ->
        Epar (Lem_list.map remove_conv_int es)
    | Ewait _ ->
        expr_
    | Eannot( fps, e) ->
        Eannot( fps, (remove_conv_int e))
    | Eexcluded( n, act) ->
        Eexcluded( n, (remove_conv_int_action act))
  )))

and remove_conv_int_action_ act_ =
   ((match act_ with
    | Create( pe1, pe2, pref) ->
        Create( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), pref)
    | CreateReadOnly( pe1, pe2, pe3, pref) ->
        CreateReadOnly( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), (remove_conv_int_pexpr pe3), pref)
    | Alloc0( pe1, pe2, pref) ->
        Alloc0( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), pref)
    | Kill( kind1, pe) ->
        Kill( kind1, (remove_conv_int_pexpr pe))
    | Store0( b, pe1, pe2, pe3, mo1) ->
        Store0( b, (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), (remove_conv_int_pexpr pe3), mo1)
    | SeqRMW( b, pe1, pe2, sym1, pe3) ->
        SeqRMW( b, (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), sym1, (remove_conv_int_pexpr pe3))
    | Load0( pe1, pe2, mo1) ->
        Load0( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), mo1)
    | RMW0( pe1, pe2, pe3, pe4, mo1, mo2) ->
        RMW0( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), (remove_conv_int_pexpr pe3), (remove_conv_int_pexpr pe4), mo1, mo2)
    | Fence0 mo1 ->
        Fence0 mo1
    | CompareExchangeStrong( pe1, pe2, pe3, pe4, mo1, mo2) ->
        CompareExchangeStrong( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), (remove_conv_int_pexpr pe3), (remove_conv_int_pexpr pe4), mo1, mo2)
    | CompareExchangeWeak( pe1, pe2, pe3, pe4, mo1, mo2) ->
        CompareExchangeWeak( (remove_conv_int_pexpr pe1), (remove_conv_int_pexpr pe2), (remove_conv_int_pexpr pe3), (remove_conv_int_pexpr pe4), mo1, mo2)
    | LinuxFence mo1 ->
        LinuxFence mo1
    | LinuxLoad( pe1, pe2, mo1) ->
        LinuxLoad( pe1, pe2, mo1)
    | LinuxStore( pe1, pe2, pe3, mo1) ->
        LinuxStore( pe1, pe2, pe3, mo1)
    | LinuxRMW( pe1, pe2, pe3, mo1) ->
        LinuxRMW( pe1, pe2, pe3, mo1)
  ))

and remove_conv_int_action (Action( loc1, (), act_)) =  (Action( loc1, (), (remove_conv_int_action_ act_)))
and remove_conv_int_paction (Paction( p, act)) =  (Paction( p, (remove_conv_int_action act)))



let is_create =  ((function
  | Expr( _, (Eaction (Paction( _, (Action( _, _, (Create( _, _, _)))))))) ->
      true
  | _ ->
      false
))

let is_kill =  ((function
  | Expr( _, (Eaction (Paction( _, (Action( _, _, (Kill( _, _)))))))) ->
      true
  | _ ->
      false
))

(* TODO: not sure if this in general a sound optimisation, but it violently reduces ND *)
let rec sequentialise_creates_kills (Expr( annot1, expr_)) =
   (Expr( annot1, (match expr_ with
    | Epure _ ->
        expr_
    | Ememop( _, _) ->
        expr_
    | Eaction _ ->
        expr_
    | Ecase( pe, pat_es) ->
        Ecase( pe, begin
          Lem_list.map (fun (pat, e) ->
            (pat, sequentialise_creates_kills e)
          ) pat_es
        end)
    | Elet( pat, pe1, e2) ->
        Elet( pat, pe1, (sequentialise_creates_kills e2))
    | Eif( pe1, e2, e3) ->
        Eif( pe1, (sequentialise_creates_kills e2), (sequentialise_creates_kills e3))
    | Eccall( _, _, _, _) ->
        expr_
    | Eproc( _, _, _) ->
        expr_
    | Eunseq es ->
        if List.for_all is_kill es then
          List.fold_right (fun e acc ->
            Esseq( (Pattern( [], (CaseBase (None, BTy_unit)))), e, (Expr( [], acc)))
          ) es (Epure (Pexpr( [], (), (PEval Vunit))))
        else
          Eunseq (Lem_list.map sequentialise_creates_kills es)
(* TODO
    | Ewseq pat ((Eunseq es1) as e1) e2 ->
        if List.all is_create es1 then
          List.foldr (fun (sym_opt, e) acc ->
            Ewseq (CaseBase sym_opt) e acc
          ) (sequentialise_creates_kills e2) (zip pat es1)
        else
          Ewseq pat (sequentialise_creates_kills e1) (sequentialise_creates_kills e2)
*)
    | Ewseq( pat, e1, e2) ->
        Ewseq( pat, (sequentialise_creates_kills e1), (sequentialise_creates_kills e2))
(* TODO
    | Esseq pat ((Eunseq es1) as e1) e2 ->
        if List.all is_create es1 then
          List.foldr (fun (sym_opt, e) acc ->
            Esseq [sym_opt] e acc
          ) (sequentialise_creates_kills e2) (zip pat es1)
        else
          Esseq pat (sequentialise_creates_kills e1) (sequentialise_creates_kills e2)
*)
    | Esseq( pat, e1, e2) ->
        Esseq( pat, (sequentialise_creates_kills e1), (sequentialise_creates_kills e2))
    | Ebound e ->
        Ebound (sequentialise_creates_kills e)
    | End es ->
        End (Lem_list.map sequentialise_creates_kills es)
    | Esave( sym_bTy, sym_bTy_pes, e) ->
        Esave( sym_bTy, sym_bTy_pes, (sequentialise_creates_kills e))
    | Erun( _, _, _) ->
        expr_
    | Epar es ->
        Epar (Lem_list.map sequentialise_creates_kills es)
    | Ewait _ ->
        expr_
    | Eannot( xs, e) ->
        Eannot( xs, (sequentialise_creates_kills e))
    | Eexcluded( _, _) ->
        expr_
  )))


(* TODO: check the soundness ... *)
(* sequentialise unseq with independant  *)


(*
let rec pure_propagation expr =
  match expr with
    | Elet pat pe1 e2 ->
        let e2' = pure_propagation e2 in
        match to_pure e2' with
          | Just pe2 ->
              Epure (PElet pat pe1 pe2)
          | Nothing ->
              Elet pat pe1 e2'
        end
    | Eif pe1 e2 e3 ->
        let e2' = pure_propagation e2 in
        let e3' = pure_propagation e3 in
        match (to_pure e2', to_pure e3') with
          | (Just pe2, Just pe3) ->
              Epure (PEif pe1 pe2 pe3)
          | (Just pe2, Nothing) ->
              Eif pe1 (Epure pe2) e3'
          | (Nothing, Just pe3) ->
              Eif pe1 e2' (Epure pe3)
          | (Nothing, Nothing) ->
              Eif pe1 e2' e3'
        end
    | Eunseq es ->
        (* TODO: do better *)
        let es' = List.map pure_propagation es in
        match to_pures es' with
          | Just pes ->
              Epure (PEtuple pes)
          | Nothing ->
              Eunseq es'
        end
    | Ewseq pat e1 e2 ->
        let e1' = pure_propagation e1 in
        match to_pure e1' with
          | Just pe1 ->
              pure_propagation (subst_syms pat pe1 e2)
          | Nothing ->
              Ewseq pat e1' (pure_propagation e2)
       end
    | Esseq pat e1 e2 ->
        let e1' = pure_propagation e1 in
        match to_pure e1' with
          | Just pe1 ->
              pure_propagation (subst_syms pat pe1 e2)
          | Nothing ->
              Esseq pat e1' (pure_propagation e2)
       end
    | Ebound e ->
        Ebound (pure_propagation e)
    | Esave sym sym_tys e ->
        Esave sym sym_tys (pure_propagation e)
    | End es ->
        End (List.map pure_propagation es)
    | Epar es ->
        Epar (List.map pure_propagation es)
    | _ ->
        expr
  end
*)





let rec isAlwaysDefined (Pexpr( _, _, pexpr_)):bool=
   ((match pexpr_ with
    | PEsym _ ->
        true
    | PEimpl _ ->
        true (* TODO: check *)
    | PEval _ ->
        true
    | PEundef( _, _) ->
        false
    | PEerror( _, _) ->
        false
    | PEctor( _, pes) ->
        List.for_all isAlwaysDefined pes
    | PEcase( pe, pat_pes) ->
        isAlwaysDefined pe && List.for_all (fun (_, pe) -> isAlwaysDefined pe) pat_pes
    | PEarray_shift( pe1, _, pe2) ->
        isAlwaysDefined pe1 && isAlwaysDefined pe2
    | PEmember_shift( pe, _, _) ->
        isAlwaysDefined pe
    | PEmemop( mop, pes) ->
        (* NOTE: doing this in case we ever add new memops that can be UB *)
        let () = ((match mop with
          | Mem_common.DeriveCap( _, _) ->
              ()
          | Mem_common.CapAssignValue ->
              ()
          | Mem_common.Ptr_tIntValue ->
              ()
          | Mem_common.ByteFromInt ->
              ()
          | Mem_common.IntFromByte ->
              ()
        )) in
        List.for_all isAlwaysDefined pes
    | PEnot pe ->
        isAlwaysDefined pe
    | PEop( _, pe1, pe2) ->
        isAlwaysDefined pe1 && isAlwaysDefined pe2
    | PEconv_int( _, pe) ->
        isAlwaysDefined pe
    | PEwrapI( _, _, pe1, pe2) ->
        isAlwaysDefined pe1 && isAlwaysDefined pe2
    | PEcatch_exceptional_condition( _, _, pe1, pe2) ->
        isAlwaysDefined pe1 && isAlwaysDefined pe2
    | PEstruct( _, ident_pes) ->
        List.for_all (fun (_, pe) -> isAlwaysDefined pe) ident_pes
    | PEunion( _, _, pe) ->
        isAlwaysDefined pe
    | PEcfunction pe ->
        isAlwaysDefined pe
    | PEmemberof( _, _, pe) ->
        isAlwaysDefined pe
    | PEcall( _, pes) ->
        (* the called function may raise an undef/error *)
        false (* List.all isAlwaysDefined pes *)
    | PElet( _, pe1, pe2) ->
        isAlwaysDefined pe1 && isAlwaysDefined pe2
    | PEif( pe1, pe2, pe3) ->
        isAlwaysDefined pe1 && (isAlwaysDefined pe2 && isAlwaysDefined pe3)
    | PEis_scalar pe ->
        isAlwaysDefined pe
    | PEis_integer pe ->
        isAlwaysDefined pe
    | PEis_signed pe ->
        isAlwaysDefined pe
    | PEis_unsigned pe ->
        isAlwaysDefined pe
    | PEbmc_assume _ ->
        false
    | PEare_compatible( pe1, pe2) ->
        isAlwaysDefined pe1 && isAlwaysDefined pe2
))

let rec pure_propagation2 ((Expr( annot1, expr_) as expr1)) =
   (let to_pure' e=
     ((match Core_aux.to_pure e with
      | Some pe ->
          if isAlwaysDefined pe then
            Some pe
          else
            None
      | None ->
          None
    )) in
  
  let to_pures' es=
     (List.fold_right (fun e acc_opt ->
      (match (to_pure' e, acc_opt) with
        | (Some pe, Some acc) ->
            Some (pe :: acc)
        | _ ->
            None
      )) es (Some [])) in
  
  (match expr_ with
    | Epure _ ->
        expr1
    | Ememop( _, _) ->
        expr1
    | Eaction _ ->
        expr1
    | Ecase( pe, pat_es) ->
        (* TODO: do more *)
        let pat_es' = (Lem_list.map (fun (pat, e) ->
          (pat, pure_propagation2 e)
        ) pat_es) in
        Expr( annot1, (Ecase( pe, pat_es')))
    | Elet( pat, pe1, e2) ->
        let e2' = (pure_propagation2 e2) in
        (match to_pure' e2' with
          | Some ((Pexpr( annot1, bTy, _) as pe2)) ->
              (* TODO: loosing std annot *)
              Core_aux.mk_pure_e (Pexpr( annot1, bTy, (PElet( pat, pe1, pe2))))
          | None ->
              Expr( annot1, (Elet( pat, pe1, e2')))
        )
    | Eif( pe1, e2, e3) ->
        let e2' = (pure_propagation2 e2) in
        let e3' = (pure_propagation2 e3) in
        (match (to_pure' e2', to_pure' e3') with
          | (Some ((Pexpr( annot1, bTy, _) as pe2)), Some pe3) ->
              (* TODO: loosing std annot *)
              Core_aux.mk_pure_e (Pexpr( annot1, bTy, (PEif( pe1, pe2, pe3))))
          | (Some pe2, None) ->
              Expr( annot1, (Eif( pe1, (Core_aux.mk_pure_e pe2), e3')))
          | (None, Some pe3) ->
              Expr( annot1, (Eif( pe1, e2', (Core_aux.mk_pure_e pe3))))
          | (None, None) ->
              Expr( annot1, (Eif( pe1, e2', e3')))
        )
    | Eccall( _, _, _, _) ->
        expr1
    | Eproc( _, _, _) ->
        expr1
    | Eunseq es ->
        (* TODO: do better *)
        let es' = (Lem_list.map pure_propagation2 es) in
        (match to_pures' es' with
          | Some pes ->
              Core_aux.mk_pure_e (Core_aux.mk_tuple_pe pes)
          | None ->
              let es'' =
                (Lem_list.map (fun e ->
                  (match to_pure' e with
                    | Some pe ->
                        Core_aux.mk_pure_e pe
                    | None ->
                        e
                  )) es') in
              Expr( annot1, (Eunseq es''))
        )
        (*
    | Ewseq (Pattern annot_ctor (CaseCtor Ctuple pats)) (Expr annot_unseq (Eunseq es)) e2 ->
        let (cont, pats', es') =
          List.foldr (fun (pat, e) (cont, pats_acc, es_acc) ->
            let e = (pure_propagation2 e) in
            match to_pure' e with
              | Just pe ->
                  (fun z -> unsafe_subst_pattern pat pe (cont z), pats_acc, es_acc)
              | Nothing ->
                  (cont, pat :: pats_acc, e :: es_acc)
            end) (id, [], []) (List.zip pats es) in
       match (pats', es') with
         | ([], []) ->
             pure_propagation2 (cont e2)
         | ([pat'], [e']) ->
             Expr annot (Ewseq pat' e' (pure_propagation2 (cont e2)))
         | _ ->
             Expr annot (Ewseq (Pattern annot_ctor (CaseCtor Ctuple pats')) (Expr annot_unseq (Eunseq es')) (pure_propagation2 (cont e2)))
       end
       *)
    | Ewseq( pat, e1, e2) ->
        let e1' = (pure_propagation2 e1) in
        (match to_pure' e1' with
          | Some pe1 ->
              (match Core_aux.subst_pattern pat pe1 e2 with
                | Some e -> pure_propagation2 e
                | None -> Expr( annot1, (Ewseq( pat, e1', (pure_propagation2 e2))))
              )
              (*pure_propagation2 (unsafe_subst_pattern pat pe1 e2)*)
          | None ->
              Expr( annot1, (Ewseq( pat, e1', (pure_propagation2 e2))))
       )
       (*
    | Esseq (Pattern annot_ctor (CaseCtor Ctuple pats)) (Expr annot_unseq (Eunseq es)) e2 ->
        let (cont, pats', es') =
          List.foldr (fun (pat, e) (cont, pats_acc, es_acc) ->
            let e = (pure_propagation2 e) in
            match to_pure' e with
              | Just pe ->
                  (fun z -> unsafe_subst_pattern pat pe (cont z), pats_acc, es_acc)
              | Nothing ->
                  (cont, pat :: pats_acc, e :: es_acc)
            end) (id, [], []) (List.zip pats es) in
       match (pats', es') with
         | ([], []) ->
             pure_propagation2 (cont e2)
         | ([pat'], [e']) ->
             Expr annot (Esseq pat' e' (pure_propagation2 (cont e2)))
         | _ ->
             Expr annot (Esseq (Pattern annot_ctor (CaseCtor Ctuple pats')) (Expr annot_unseq (Eunseq es')) (pure_propagation2 (cont e2)))
       end
       *)
    | Esseq( pat, e1, e2) ->
        let e1' = (pure_propagation2 e1) in
        (match to_pure' e1' with
          | Some pe1 ->
              (match Core_aux.subst_pattern pat pe1 e2 with
                | Some e -> pure_propagation2 e
                | None -> Expr( annot1, (Esseq( pat, e1', (pure_propagation2 e2))))
              )
              (*pure_propagation2 (unsafe_subst_pattern pat pe1 e2)*)
          | None ->
              Expr( annot1, (Esseq( pat, e1', (pure_propagation2 e2))))
       )
    | Ebound e ->
        Expr( annot1, (Ebound (pure_propagation2 e)))
    | End es ->
        Expr( annot1, (End (Lem_list.map pure_propagation2 es)))
    | Esave( sym1, sym_tys, e) ->
        Expr( annot1, (Esave( sym1, sym_tys, (pure_propagation2 e))))
    | Erun( _, _, _) ->
        expr1
    | Epar es ->
        Expr( annot1, (Epar (Lem_list.map pure_propagation2 es)))
    | Ewait _ ->
        expr1
    | Eannot( xs, e) ->
        Expr( annot1, (Eannot( xs, (pure_propagation2 e))))
    | Eexcluded( _, _) ->
        expr1
  ))






(* TODO, this is not correct!!

consider:

case sym of Specified _ => e1 | _ => e2

where sym is of type loaded oTy

this could match for e1, but the current code assumes it doesn't and match e2 instead...


*)
let rec simpl_match_pattern (Pattern( _, pat)) pe =
   (if not (isAlwaysDefined pe) then
    None
  else (match (pat, pe) with
(*
    | (_, Pexpr _ (PEval cval)) ->
        List.map (fun (sym, cval) ->
          (sym, Pexpr (bTy (PEval
        ) (Caux.match_pattern pat cval)
*)
    | (CaseBase (None, _), _) ->
        Some []
    | (CaseBase (Some sym1, _), _) ->
        Some [(sym1, pe)]
    | (CaseCtor( Cspecified, [pat']), Pexpr( _, _, (PEval (Vloaded (LVspecified cval))))) ->
        simpl_match_pattern pat' (Core_aux.mk_value_pe (Vobject cval))
    | (CaseCtor( Cspecified, [pat']), Pexpr( _, _, (PEctor( Cspecified, [pe'])))) ->
        simpl_match_pattern pat' pe'
(*
    | (CaseCtor Cunspecified [pat'], Vloaded (LVunspecified ty)) ->
        match_pattern pat' (Vctype ty)
*)
    | (CaseCtor( Ctuple, pats'), Pexpr( _, _, (PEval (Vtuple cvals)))) ->
        if not ((List.length pats') = (List.length cvals)) then
          None
        else
          List.fold_right (fun (pat', cval) acc ->
            Lem.option_bind acc (fun xs ->
              Lem.option_bind (simpl_match_pattern pat' (Core_aux.mk_value_pe cval)) (fun x ->
                Some (List.rev_append (List.rev x) xs)
              )
            )
          ) (Lem_list.list_combine pats' cvals) (Some [])
    | (CaseCtor( Ctuple, pats'), Pexpr( _, _, (PEctor( Ctuple, pes')))) ->
        if not ((List.length pats') = (List.length pes')) then
          None
        else
          List.fold_right (fun (pat', pe') acc ->
            Lem.option_bind acc (fun xs ->
              Lem.option_bind (simpl_match_pattern pat' pe') (fun x ->
                Some (List.rev_append (List.rev x) xs)
              )
            )
          ) (Lem_list.list_combine pats' pes') (Some [])
    | _ ->
        None
  ))

let rec simpl_select_case unsafe_subst_sym match_pe:('b generic_pattern*'a)list ->'a option=  ((function
  | [] ->
      None
  | (pat, e) :: pat_es' ->
      (match simpl_match_pattern pat match_pe with
        | None ->
            (* trying the next branch *)
            simpl_select_case unsafe_subst_sym match_pe pat_es'
        | Some (sym_pes) -> Some (List.fold_right (fun (sym1, pe') acc ->
              unsafe_subst_sym sym1 pe' acc
            ) sym_pes e)
      )
))

let rec simpl_case_pexpr ((Pexpr( annot1, bTy, pexpr_) as pexpr1)) =
   (let wrap z=  (Pexpr( annot1, bTy, z)) in
  (match pexpr_ with
    | PEsym _ ->
        pexpr1
    | PEimpl _ ->
        pexpr1
    | PEval _ ->
        pexpr1
    | PEundef( _, _) ->
        pexpr1
    | PEerror( _, _) ->
        pexpr1
    | PEctor( ctor1, pes) -> wrap (PEctor( ctor1, (Lem_list.map simpl_case_pexpr pes)))
    | PEcase( pe, pat_pes) ->
        (match simpl_select_case Core_aux.unsafe_subst_sym_pexpr pe pat_pes with
          | None -> wrap (PEcase( (simpl_case_pexpr pe), (Lem_list.map (fun (pat, pe) -> (pat, simpl_case_pexpr pe)) pat_pes)))
          | Some pe' ->
              simpl_case_pexpr pe'
        )
    | PEarray_shift( pe1, ty1, pe2) -> wrap (PEarray_shift( (simpl_case_pexpr pe1), ty1, (simpl_case_pexpr pe2)))
    | PEmember_shift( pe, sym1, ident) -> wrap (PEmember_shift( (simpl_case_pexpr pe), sym1, ident))
    | PEmemop( mop, pes) -> wrap (PEmemop( mop, (Lem_list.map simpl_case_pexpr pes)))
    | PEnot pe -> wrap (PEnot (simpl_case_pexpr pe))
    | PEop( bop, pe1, pe2) -> wrap (PEop( bop, (simpl_case_pexpr pe1), (simpl_case_pexpr pe2)))
    | PEconv_int( ity, pe) -> wrap (PEconv_int( ity, (simpl_case_pexpr pe)))
    | PEwrapI( ity, iop1, pe1, pe2) -> wrap (PEwrapI( ity, iop1, (simpl_case_pexpr pe1), (simpl_case_pexpr pe2)))
    | PEcatch_exceptional_condition( ity, iop1, pe1, pe2) -> wrap (PEcatch_exceptional_condition( ity, iop1, (simpl_case_pexpr pe1), (simpl_case_pexpr pe2)))
    | PEstruct( sym1, ident_pes) -> wrap (PEstruct( sym1, (Lem_list.map (fun (ident, pe) -> (ident, simpl_case_pexpr pe)) ident_pes)))
    | PEunion( sym1, ident, pe) -> wrap (PEunion( sym1, ident, (simpl_case_pexpr pe)))
    | PEcfunction pe -> wrap (PEcfunction (simpl_case_pexpr pe))
    | PEmemberof( tag_sym, memb_ident, pe) -> wrap (PEmemberof( tag_sym, memb_ident, (simpl_case_pexpr pe)))
    | PEcall( nm, pes) -> wrap (PEcall( nm, (Lem_list.map simpl_case_pexpr pes)))
    | PElet( pat, pe1, pe2) -> wrap (PElet( pat, (simpl_case_pexpr pe1), (simpl_case_pexpr pe2)))
    | PEif( pe1, pe2, pe3) -> wrap (PEif( (simpl_case_pexpr pe1), (simpl_case_pexpr pe2), (simpl_case_pexpr pe3)))
    | PEis_scalar pe -> wrap (PEis_scalar (simpl_case_pexpr pe))
    | PEis_integer pe -> wrap (PEis_integer (simpl_case_pexpr pe))
    | PEis_signed pe -> wrap (PEis_signed (simpl_case_pexpr pe))
    | PEis_unsigned pe -> wrap (PEis_unsigned (simpl_case_pexpr pe))
    | PEbmc_assume pe ->
        pexpr1
    | PEare_compatible( pe1, pe2) -> wrap (PEare_compatible( (simpl_case_pexpr pe1), (simpl_case_pexpr pe2)))
  ))

let rec simpl_case ((Expr( annot1, expr_) as expr1)) =
   (let wrap z=  (Expr( annot1, z)) in
  (match expr_ with
    | Epure pe -> wrap (Epure (simpl_case_pexpr pe))
    | Ememop( _, _) ->
        expr1
    | Eaction _ ->
        expr1
    | Ecase( pe, pat_es) ->
        (match simpl_select_case Core_aux.unsafe_subst_sym_expr pe pat_es with
          | None -> wrap (Ecase( (simpl_case_pexpr pe), (Lem_list.map (fun (pat, e) -> (pat, simpl_case e)) pat_es)))
          | Some e' ->
              simpl_case e'
        )
    | Elet( pat, pe1, e2) -> wrap (Elet( pat, pe1, (simpl_case e2)))
    | Eif( pe1, e2, e3) -> wrap (Eif( pe1, (simpl_case e2), (simpl_case e3)))
    | Eccall( _, _, _, _) ->
        expr1
    | Eproc( _, _, _) ->
        expr1
    | Eunseq es -> wrap (Eunseq (Lem_list.map simpl_case es))
    | Ewseq( pat, e1, e2) -> wrap (Ewseq( pat, (simpl_case e1), (simpl_case e2)))
    | Esseq( pat, e1, e2) -> wrap (Esseq( pat, (simpl_case e1), (simpl_case e2)))
    | Ebound e -> wrap (Ebound (simpl_case e))
    | End es -> wrap (End (Lem_list.map simpl_case es))
    | Esave( sym_bTy, xs, e) -> wrap (Esave( sym_bTy, xs, (simpl_case e)))
    | Erun( _, _, _) ->
        expr1
    | Epar es -> wrap (Epar (Lem_list.map simpl_case es))
    | Ewait _ ->
        expr1
    | Eannot( xs, e) -> wrap (Eannot( xs, (simpl_case e)))
    | Eexcluded( _, _) ->
        expr1
  ))
















(* ========================================================================== *)

let rewrite_pexpr pexpr1:'a=
(*  remove_conv_int_pexpr pexpr *)
   pexpr1


let rewrite_expr expr1 =
   (( (fun x->(* simpl_case -| *)pure_propagation2 (flatten_seqs x))) expr1)
(*
  (pure_propagation2 -| remove_conv_int -| flatten_seqs -|
   (* remove_dead -| remove_seqs -| remove_unseqs -| flatten_seqs -| *) remove_skips -|
   sequentialise_creates_kills) expr
*)

let rewrite_fun_map dict_Map_MapKeyType_b fun_map1 =
   (Pmap.map ((function
    | Fun( ty1, params, pe) ->
        Fun( ty1, params, (rewrite_pexpr pe))
    | ProcDecl( loc1, ty1, params) ->
        ProcDecl( loc1, ty1, params)
    | BuiltinDecl( loc1, ty1, params) ->
        BuiltinDecl( loc1, ty1, params)
    | Proc( loc1, mrk, ty1, params, e) ->
        Proc( loc1, mrk, ty1, params, (rewrite_expr e))
  )) fun_map1)


let rewrite_glob_map globs_map =
   (Lem_list.map (fun (name1, glb) ->
    (name1, (match glb with
      | GlobalDef( ty1, e) ->
          GlobalDef( ty1, (rewrite_expr e))
      | GlobalDecl ty1 ->
          GlobalDecl ty1
    ))
  ) globs_map)


(* TODO *)
let rewrite_file file1 =
   ({ file1 with funs=  (rewrite_fun_map 
  (instance_Map_MapKeyType_var_dict
     Symbol.instance_Basic_classes_SetType_Symbol_sym_dict) file1.funs);
               globs= (rewrite_glob_map file1.globs) })
