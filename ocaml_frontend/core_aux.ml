(*Generated by Lem from frontend/model/core_aux.lem.*)


open Lem_pervasives
open Utils
open Lem_show
open Core
open Ctype
open Annot
open Lem_map
open Lem_map_extra
(*import AilSyntax Ctype_aux*) 
(*import Product Exception Mem Mem_common Mem_aux*)

open Errors

(*import Debug Pp*)

(*import Nondeterminism*)
module ND = Nondeterminism




(*val     core_object_type_of_ctype: ctype -> maybe core_object_type*)
let rec core_object_type_of_ctype (Ctype( _, ty1)) =
   ((match ty1 with
   | Void ->
       None
   | Basic (Integer _) ->
       Some OTy_integer
   | Basic (Floating _) ->
       Some OTy_floating
   | Array( ty1, _) ->
       (match core_object_type_of_ctype ty1 with
         | Some oTy ->
             Some (OTy_array oTy)
         | None ->
             Cerb_debug.error "Core_aux.core_object_type_of_ctype: Array found a Nothing"
       )
   | Function( (_, ret_ty), xs, isVariadic) ->
       Cerb_debug.error "core_object_type_of_ctype: not core function object"
   | FunctionNoParams _ ->
       Cerb_debug.error "core_object_type_of_ctype: not core function (no params) object"
   | Pointer( _, _) ->
       Some OTy_pointer
   | Atomic ty1 ->
       core_object_type_of_ctype ty1
   | Struct tag_sym ->
       Some (OTy_struct tag_sym)
   | Union tag_sym ->
       Some (OTy_union tag_sym)
   | Byte ->
       (* May need to revisit based on CN *)
       Some OTy_integer
  ))


let rec loadedValueFromMemValue mem_val =
   (let () = (Cerb_debug.print_debug 6 [] (fun () ->
    "loadedValueFromMemValue ==> " ^ Impl_mem.string_of_mem_value mem_val
  )) in
  Impl_mem.case_mem_value mem_val
    (fun ty1                -> (fromJust "loadedValueFromMemValue" (core_object_type_of_ctype ty1), LVunspecified ty1))
    (fun _ _               -> Cerb_debug.error "[Core_aux.loadedValueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, LVspecified (OVinteger ival)))
    (fun _ fval            -> (OTy_floating, LVspecified (OVfloating fval)))
    (fun _ ptr_val         -> (OTy_pointer, LVspecified (OVpointer ptr_val)))
    (fun mem_vals          ->
      (match Lem_list.map loadedValueFromMemValue mem_vals with
        | [] ->
            Cerb_debug.error "[Core_aux.loadedValueFromMemValue] empty array"
        | (oTy, lval) :: oTy_lvals ->
            if List.exists (fun (oTy', _) -> ((fun x y -> not (eq_core_object_type x y)) oTy oTy')) oTy_lvals then
              Cerb_debug.error "[Core_aux.loadedValueFromMemValue] heterogenous array"
            else
              (OTy_array oTy, LVspecified (OVarray (lval :: Lem_list.map snd oTy_lvals)))
      ))
    (fun sym1 xs            -> (OTy_struct sym1, LVspecified (OVstruct( sym1, xs))))
    (fun sym1 ident mem_val -> (OTy_union sym1, LVspecified (OVunion( sym1, ident, mem_val)))))


(*val valueFromMemValue: Mem.mem_value -> core_object_type * value*)
let valueFromMemValue mem_val =
   (let () = (Cerb_debug.print_debug 6 [] (fun () ->
    "valueFromMemValue ==> " ^ Impl_mem.string_of_mem_value mem_val
  )) in
  Impl_mem.case_mem_value mem_val
    (fun ty1                -> (fromJust "Core_aux.valueFromMemValue" (core_object_type_of_ctype ty1), Vloaded (LVunspecified ty1)))
    (fun _ _               -> Cerb_debug.error "[Core_aux.valueFromMemValue] concurrency read")
    (fun _ ival            -> (OTy_integer, Vloaded (LVspecified (OVinteger ival))))
    (fun _ fval            -> (OTy_floating, Vloaded (LVspecified (OVfloating fval))))
    (fun _ ptr_val         -> (OTy_pointer, Vloaded (LVspecified (OVpointer ptr_val))))
    (fun mem_vals          -> let (oTys, lvals) = (List.split (Lem_list.map loadedValueFromMemValue mem_vals)) in
                              let oTy = ((match oTys with
                                | [] ->
                                    (* Something went wrong in the MLM *)
                                    Cerb_debug.error "Core_aux.valueFromMemValue ==> empty array"
                                | oTy :: _ ->
                                    oTy
                              )) in
                              (OTy_array oTy, Vloaded (LVspecified (OVarray lvals))))
    (fun sym1 xs            -> (OTy_struct sym1, Vloaded (LVspecified (OVstruct( sym1, xs)))))
    (fun sym1 ident mem_val -> (OTy_union sym1, Vloaded (LVspecified (OVunion( sym1, ident, mem_val))))))

(*val     memValueFromValue: ctype -> value -> maybe Mem.mem_value*)
let rec memValueFromValue ty1 cval =
   (let (Ctype( annots1, ty_)) = (unatomic ty1) in
  (match (ty_, cval) with
    | (_, Vunit) ->
        None
    | (_, Vtrue) ->
        None
    | (_, Vfalse) ->
        None
    | (_, Vlist( _, _)) ->
        None
    | (_, Vtuple _) ->
        None
    | (_, Vctype _) ->
        None
    | (_, Vloaded (LVunspecified ty')) ->
        Some (Impl_mem.unspecified_mval ty') (* TODO: check ty = ty'? *)
    | (Basic (Integer ity), Vobject (OVinteger ival)) ->
        Some (Impl_mem.integer_value_mval ity ival)
    | (Basic (Integer ity), Vloaded (LVspecified (OVinteger ival))) ->
        Some (Impl_mem.integer_value_mval ity ival)
    | (Byte, Vobject (OVinteger ival)) ->
        Some (Impl_mem.integer_value_mval (Unsigned Ichar) ival)
    | (Byte, Vloaded (LVspecified (OVinteger ival))) ->
        Some (Impl_mem.integer_value_mval (Unsigned Ichar) ival)
    | (Basic (Floating fty), Vloaded (LVspecified (OVfloating fval))) ->
        Some (Impl_mem.floating_value_mval fty fval)
    | (Basic (Floating fty), Vobject (OVfloating fval)) ->
        Some (Impl_mem.floating_value_mval fty fval)
    | (Pointer( _, ref_ty), Vobject (OVpointer ptr_val)) -> (* TODO: not sure about this *)
        Some (Impl_mem.pointer_mval ref_ty ptr_val)
    | (Pointer( _, ref_ty), Vloaded (LVspecified (OVpointer ptr_val))) ->
        Some (Impl_mem.pointer_mval ref_ty ptr_val)
    | (Array( elem_ty, _), Vloaded (LVspecified (OVarray lvals))) ->
        (* TODO: check that the sizes match? *) Lem.option_case None (fun z -> Some (Impl_mem.array_mval z)) (List.fold_right (fun lval acc_opt ->
            (match (memValueFromValue elem_ty (Vloaded lval), acc_opt) with
              | (Some mem_val, Some acc) ->
                  Some (mem_val :: acc)
              | _ ->
                  None
            )
          ) lvals (Some []))
    | (Struct tag_sym1, Vloaded (LVspecified (OVstruct( tag_sym2, xs)))) ->
        let () = (Cerb_debug.print_debug 2 [] (fun () -> "Comparing struct tag symbols: " ^ (Symbol.show_raw tag_sym1 ^ (" = " ^ Symbol.show_raw tag_sym2)))) in
        if Ctype_aux.are_compatible0
          (no_qualifiers, Ctype( [], (Struct tag_sym1)))
          (no_qualifiers, Ctype( [], (Struct tag_sym2)))
        then
          Some (Impl_mem.struct_mval tag_sym1 xs)
        else
          None
    | (Union tag_sym1, Vloaded (LVspecified (OVunion( tag_sym2, ident, mem_val)))) ->
        if (match (tag_sym1, tag_sym2) with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  ) then
          Some (Impl_mem.union_mval tag_sym1 ident mem_val)
        else
          None
    | _ ->
        let () = (Cerb_debug.print_debug 5 [] (fun () -> "memValueFromValue("
                 ^ (String_core_ctype.string_of_ctype (Ctype( [], ty_)) ^ (", " ^  (String_core.string_of_value cval ^ ")"))))) in
        None
  ))




(* Core pattern builders **************************************************** *)

(*val mk_empty_pat: core_base_type -> pattern*)
let mk_empty_pat bTy =
   (Pattern( [], (CaseBase (None, bTy))))

(*val mk_sym_pat_: forall 'sym. list Annot.annot -> maybe 'sym -> core_base_type -> generic_pattern 'sym*)
let mk_sym_pat_ annots1 msym bTy =
   (Pattern( annots1, (CaseBase (msym, bTy))))

(*val mk_sym_pat: Symbol.sym -> core_base_type -> pattern*)
let mk_sym_pat sym1 bty =  (mk_sym_pat_ [] (Some sym1) bty)

(*val mk_tuple_pat: list pattern -> pattern*)
let mk_tuple_pat =  ((function
  | [] ->
      Cerb_debug.error "[Core_aux.mk_tuple_pat] called with |pats| = 0"
  | [pat] ->
      pat
  | pats ->
      Pattern( [], (CaseCtor( Ctuple, pats)))
))

(*val mk_specified_pat_: forall 'bty 'sym. list Annot.annot -> generic_pattern 'sym -> generic_pattern 'sym*)
let mk_specified_pat_ annots1 pat =
   (Pattern( annots1, (CaseCtor( Cspecified, [pat]))))

(*val mk_specified_pat: pattern -> pattern*)
let mk_specified_pat pat =  (mk_specified_pat_ [] pat)

(*val mk_unspecified_pat_: forall 'bty 'sym. list Annot.annot -> generic_pattern 'sym -> generic_pattern 'sym*)
let mk_unspecified_pat_ annots1 pat =
   (Pattern( annots1, (CaseCtor( Cunspecified, [pat]))))

(*val mk_unspecified_pat: pattern -> pattern*)
let mk_unspecified_pat pat =  (mk_unspecified_pat_ [] pat)


(* Core pexpr builders  ***************************************************** *)
(*val annotate_integer_type_pexpr : integerType -> pexpr -> pexpr*)
let annotate_integer_type_pexpr ity (Pexpr( annots1, (), expr_)) =
   (Pexpr( (Avalue (Ainteger ity) :: annots1), (), expr_))

(*val maybe_annotate_integer_type_pexpr : ctype -> pexpr -> pexpr*)
let maybe_annotate_integer_type_pexpr (Ctype( _, ty_)) pe =
   ((match ty_ with
    | Basic (Integer ity) -> annotate_integer_type_pexpr ity pe
    | _ -> pe
  ))

(*val mk_sym_pe: Symbol.sym -> pexpr*)
let mk_sym_pe sym1 =
   (Pexpr( [], (), (PEsym sym1)))

(* TODO: mk_impl_pe *)

(* TODO: PEval Vconstrained, Vobject *)

(*val mk_integer_pe: integer -> pexpr*)
let mk_integer_pe n =
   (Pexpr( [], (), (PEval (Vobject (OVinteger (Impl_mem.integer_ival n))))))

(*val mk_floating_value_pe: Mem.floating_value -> pexpr*)
let mk_floating_value_pe fval =
   (Pexpr( [], (), (PEval (Vobject (OVfloating fval)))))

(*val mk_nullptr_pe: ctype -> pexpr*)
let mk_nullptr_pe ref_ty =
   (Pexpr( [], (), (PEval (Vobject (OVpointer (Impl_mem.null_ptrval ref_ty))))))

(*val mk_specified_pe: pexpr -> pexpr*)
let mk_specified_pe pe =
     (Pexpr( [], (), (PEctor( Cspecified, [pe]))))

(*val mk_unspecified_pe: ctype -> pexpr*)
let mk_unspecified_pe ty1 =
   (Pexpr( [], (), (PEval (Vloaded (LVunspecified ty1)))))

(*val mk_array_pe: list pexpr -> pexpr*)
let mk_array_pe pes =
   (Pexpr( [], (), (PEctor( Carray, pes))))

(*val mk_unit_pe: pexpr*)
let mk_unit_pe =
   (Pexpr( [], (), (PEval Vunit)))


let mk_boolean_v =  ((function
  | true -> Vtrue
  | false -> Vfalse
  ))

(*val mk_boolean_pe: bool -> pexpr*)
let mk_boolean_pe b =
   (Pexpr( [], (), (PEval (mk_boolean_v b))))

(* TODO: PEval Vtrue, Vfalse *)

(*val mk_ail_ctype_pe: ctype -> pexpr*)
let mk_ail_ctype_pe ty1 =
   (Pexpr( [], (), (PEval (Vctype ty1))))

(*val mk_ctype_pe: ctype -> pexpr*)
let mk_ctype_pe ty1 =
   (Pexpr( [], (), (PEval (Vctype ty1))))

(*val     mk_list_pe: core_base_type -> list pexpr -> pexpr*)
let rec mk_list_pe bTy pes =
   (Pexpr( [], (), (match pes with
    | [] ->
        PEctor( (Cnil bTy), [])
    | pe :: pes' ->
        PEctor( Ccons, [pe; mk_list_pe bTy pes'])
  )))

(*val mk_tuple_pe: list pexpr -> pexpr*)
let mk_tuple_pe =  ((function
  | [] ->
      Cerb_debug.error "Core_aux.mk_tuple_pe []"
  | [pe] ->
      pe
  | pes ->
      Pexpr( [], (), (PEctor( Ctuple, pes)))
))

(*val mk_ivmax_pe: pexpr -> pexpr*)
let mk_ivmax_pe pe =
   (Pexpr( [], (), (PEctor( Civmax, [pe]))))

(*
val mk_ivmin_pe: pexpr -> pexpr
let mk_ivmin_pe pe =
  Pexpr [] () (PEctor Civmin [pe])
*)

(*val mk_sizeof_pe: pexpr -> pexpr*)
let mk_sizeof_pe pe =
   (Pexpr( [], (), (PEctor( Civsizeof, [pe]))))

(*val mk_alignof_pe: pexpr -> pexpr*)
let mk_alignof_pe pe =
   (Pexpr( [], (), (PEctor( Civalignof, [pe]))))

(*val mk_nullcap_pe: bool -> pexpr*)
let mk_nullcap_pe is_signed =
   (Pexpr( [], (), (PEctor( (CivNULLcap is_signed), []))))

(*val mk_undef_pe: Loc.t -> Undefined.undefined_behaviour -> pexpr*)
let mk_undef_pe loc1 ub =
   (Pexpr( [], (), (PEundef( loc1, ub))))

(*val mk_error_pe: string -> pexpr -> pexpr*)
let mk_error_pe str pe =
   (Pexpr( [], (), (PEerror( str, pe))))

(*val mk_not_pe: pexpr -> pexpr*)
let mk_not_pe pe =
   (Pexpr( [], (), (PEnot pe)))

(*val mk_op_pe: binop -> pexpr -> pexpr -> pexpr*)
let mk_op_pe bop pe1 pe2 =
   (Pexpr( [], (), (PEop( bop, pe1, pe2))))

(*val mk_conv_int_pe: integerType -> pexpr -> pexpr*)
let mk_conv_int_pe ity pe =
   (Pexpr( [], (), (PEconv_int( ity, pe))))

(*val mk_wrapI_pe: integerType -> iop -> pexpr -> pexpr -> pexpr*)
let mk_wrapI_pe ity iop1 pe1 pe2 =
   (Pexpr( [], (), (PEwrapI( ity, iop1, pe1, pe2))))

(*val mk_catch_exceptional_condition_pe: integerType -> iop -> pexpr -> pexpr -> pexpr*)
let mk_catch_exceptional_condition_pe ity iop1 pe1 pe2 =
   (Pexpr( [], (), (PEcatch_exceptional_condition( ity, iop1, pe1, pe2))))

(*val mk_let_pe: pattern -> pexpr -> pexpr -> pexpr*)
let mk_let_pe pat pe1 pe2 =
   (Pexpr( [], (), (PElet( pat, pe1, pe2))))


(*val mk_if_pe: pexpr -> pexpr -> pexpr -> pexpr*)
let mk_if_pe pe1 pe2 pe3 =
   (Pexpr( [], (), (PEif( pe1, pe2, pe3))))

(*val mk_array_shift: pexpr -> ctype -> pexpr -> pexpr*)
let mk_array_shift pe1 ty1 pe2 =
   (Pexpr( [], (), (PEarray_shift( pe1, ty1, pe2))))

(*val mk_member_shift_pe: pexpr -> Symbol.sym -> Symbol.identifier -> pexpr*)
let mk_member_shift_pe pe1 tag_sym member_ident =
   (Pexpr( [], (), (PEmember_shift( pe1, tag_sym, member_ident))))

(*val mk_memop_pe: Mem_common.pure_memop -> list pexpr -> pexpr*)
let mk_memop_pe mop pes =
   (Pexpr( [], (), (PEmemop( mop, pes))))

(*val mk_case_pe: pexpr -> list (pattern * pexpr) -> pexpr*)
let mk_case_pe pe pat_pes =
   (Pexpr( [], (), (PEcase( pe, pat_pes))))

(* integerType is the type annotation placed on the 0 literal *)
(* TODO: in the move to OCaml, have mk_integer_pe take an optional integerType
 * instead of doing something special here
 *)
(*val mk_neg_pe: integerType -> pexpr -> pexpr*)
let mk_neg_pe ity pe =
   (Pexpr( [], (), (PEop( OpSub, (annotate_integer_type_pexpr ity (mk_integer_pe( (Nat_big_num.of_int 0)))), pe))))

(*val mk_struct_pe: Symbol.sym -> list (Symbol.identifier * pexpr) -> pexpr*)
let mk_struct_pe tag_sym xs =
   (Pexpr( [], (), (PEstruct( tag_sym, xs))))

(*val mk_union_pe: Symbol.sym -> Symbol.identifier -> pexpr -> pexpr*)
let mk_union_pe tag_sym memb_ident pe =
   (Pexpr( [], (), (PEunion( tag_sym, memb_ident, pe))))

(*val mk_memberof_pe: Symbol.sym -> Symbol.identifier -> pexpr -> pexpr*)
let mk_memberof_pe tag_sym memb_ident pe =
   (Pexpr( [], (), (PEmemberof( tag_sym, memb_ident, pe))))

(*val mk_value_pe: value -> pexpr*)
let mk_value_pe cval =
   (Pexpr( [], (), (PEval cval)))

(*val mk_cfunction_pe: pexpr -> pexpr*)
let mk_cfunction_pe pe =
   (Pexpr( [], (), (PEcfunction pe)))

(*val mk_std_pe: string -> pexpr -> pexpr*)
let mk_std_pe std (Pexpr( annot1, bty, pe_)) =
   (Pexpr( ((Astd std)::annot1), bty, pe_))

(*val mk_std_undef_pe: Loc.t -> string -> Undefined.undefined_behaviour -> pexpr*)
let mk_std_undef_pe loc1 std ub =  (mk_std_pe std (mk_undef_pe loc1 ub))

(*val mk_std_pair_pe: string -> pexpr * pexpr -> pexpr * pexpr*)
let mk_std_pair_pe std (pe1, pe2) =
   (mk_std_pe std pe1, mk_std_pe std pe2)


(*val mk_call_pe: name -> list pexpr -> pexpr*)
let mk_call_pe nm pes =
   (Pexpr( [], (), (PEcall( nm, pes))))

(*val mk_are_compatible: pexpr -> pexpr -> pexpr*)
let mk_are_compatible pe1 pe2 =
   (Pexpr( [], (), (PEare_compatible( pe1, pe2))))




(* Some common undef *)

(*val mk_undef_exceptional_condition: Loc.t -> pexpr*)
let mk_undef_exceptional_condition loc1 =
   (mk_std_undef_pe loc1 "ยง6.5#5" Undefined.UB036_exceptional_condition)












(*val bitwise_complement_pe: pexpr -> pexpr -> pexpr*)
(*
val integer_encode_pe:     pexpr -> pexpr -> pexpr
val integer_decode_pe:     pexpr -> pexpr -> pexpr
*)

let bitwise_complement_pe pe1 pe2 =
   (Pexpr( [], (), (PEctor( CivCOMPL, [pe1; pe2]))))
(*
  Pexpr [] () (PEcall (Impl Implementation.Bitwise_complement) [pe1; pe2])
*)
(*
let integer_encode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation.Integer__encode) [pe1; pe2])
let integer_decode_pe pe1 pe2 =
  Pexpr [] () (PEcall (Impl Implementation.Integer__decode) [pe1; pe2])
*)

(* Some aliases for positive actions *)
let pcreate loc1 al ty1 pref =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (Create( al, ty1, pref)))))))))
let pcreate_readonly loc1 al ty1 init1 pref =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (CreateReadOnly(  al, ty1, init1, pref)))))))))
(*
let palloc loc al e pref =
  Expr [] (Eaction (Paction Pos (Action loc default (Alloc al e pref))))
*)
let pkill loc1 kind1 x =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (Kill( kind1, x)))))))))
let pstore loc1 ty1 x n mo1 =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (Store0( false, ty1, x, n, mo1)))))))))
let pstore_lock loc1 ty1 x n mo1 =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (Store0( true, ty1, x, n, mo1)))))))))
let pload loc1 ty1 x mo1 =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (Load0( ty1, x, mo1)))))))))
(*
let prmw loc ty x n1 n2 mo1 mo2 =
  Expr [] (Eaction (Paction Pos (Action loc default (RMW ty x n1 n2 mo1 mo2))))
*)
let pcompare_exchange_strong loc1 ty1 x n1 n2 mo1 mo2 =
   (Expr( [], (Eaction (Paction( Pos, (
        Action( loc1, 
  (), (CompareExchangeStrong( ty1, x, n1, n2, mo1, mo2)))))))))
let pcompare_exchange_weak loc1 ty1 x n1 n2 mo1 mo2 =
   (Expr( [], (Eaction (Paction( Pos, (
        Action( loc1, 
  (), (CompareExchangeWeak( ty1, x, n1, n2, mo1, mo2)))))))))
let plinux_load loc1 ty1 x mo1 =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (LinuxLoad( ty1, x, mo1)))))))))
let plinux_store loc1 ty1 x n mo1 =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (LinuxStore( ty1, x, n, mo1)))))))))
let plinux_rmw loc1 ty1 x n mo1 =
   (Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (LinuxRMW( ty1, x, n, mo1)))))))))

(*import Global Cmm_csem*)
let seq_rmw loc1 with_forward ty1 oTy x sym1 upd =
   (let backend = (Cerb_global.backend_name ()) in
  if (backend = "Cn") || (backend = "Bmc") then
    (* TODO: compatibility mode for Cn, until SeqRMW is supported *)
    if with_forward then
      Cerb_debug.error "TODO: Core_aux.seq_rmw (comptability mode) with_forward"
    else
      Expr( [], (Ewseq( (mk_sym_pat sym1 (*TODO*)(BTy_loaded oTy)),
                    (pload 
  loc1 ty1 x Cmm_csem.NA),
                    (Expr( [], (Ewseq( (mk_empty_pat BTy_unit),
                                    (pstore 
  loc1 ty1 x upd Cmm_csem.NA),
                                    (Expr( [], (Epure (mk_sym_pe sym1)))))))))))
  else
    Expr( [], (Eaction (Paction( Pos, (Action( loc1, 
  (), (SeqRMW( with_forward, ty1, x, sym1, upd)))))))))







(*


(*

TODO: bring back structs/unions

  let proj_member = function
    | Ail.MEMBER ty               -> MEMBER (proj_ctype ty)
    | Ail.BITFIELD ty w is_packed -> BITFIELD (proj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Ctype.Void             -> Void
    | Ctype.Basic bt         -> Basic bt
    | Ctype.Array ty n       -> Array (proj_ctype ty) n
    | Ctype.Function ty ps b -> Function (proj_ctype ty) (List.map (proj_ctype -| snd) ps) b
    | Ctype.Pointer _ ty    -> Pointer (proj_ctype ty)
    | Ctype.Atomic ty        -> Atomic (proj_ctype ty)
(*
    | Ail.STRUCT _ tag members -> STRUCT tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.UNION  _ tag members -> UNION  tag (List.map (fun (a, m) -> (a, proj_member m)) members)
    | Ail.ENUM id              -> ENUM id
    | Ail.ATOMIC ty            -> ATOMIC (proj_ctype ty)
    | Ail.TYPEDEF _            -> error "[Core_aux.proj_ctype] found a A.TYPEDEF"
    | Ail.SIZE_T               -> SIZE_T
    | Ail.INTPTR_T             -> INTPTR_T
    | Ail.WCHAR_T              -> WCHAR_T
    | Ail.CHAR16_T             -> CHAR16_T
    | Ail.CHAR32_T             -> CHAR32_T
*)
end
*)

(*
(* Bring back a Core.ctype into a Ail.ctype (with loss of qualifiers if coming from proj_ctype) *)
let rec unproj_ctype ty =
  Ctype.Ctype [] (match ty with
    | Void ->
        Ctype.Void
    | Basic bty ->
        Ctype.Basic bty
    | Array ty n_opt ->
        Ctype.Array (unproj_ctype ty) n_opt
    | Function (qs, ty) qs_tys is_variadic ->
        (* NOTE: there is a potential loss of information here for hasProto and
           inside the parameters with isRegister. But this shouldn't matter to
           the dynamics *)
        Ctype.Function false (qs, unproj_ctype ty) (
          List.map (fun (qs,ty) ->
            (qs, unproj_ctype ty, false)
          ) qs_tys
        ) is_variadic
    | Pointer qs ty ->
        Ctype.Pointer qs (unproj_ctype ty)
    | Atomic ty ->
        Ctype.Atomic (unproj_ctype ty)
    | Struct tag ->
        Ctype.Struct tag
    | Union tag ->
        Ctype.Union tag
  end)
*)

(*
(*
  let unproj_member = function
    | MEMBER ty               -> Ail.MEMBER (unproj_ctype ty)
    | BITFIELD ty w is_packed -> Ail.BITFIELD (unproj_ctype ty) w is_packed
  end in
*)
  match ty with
    | Void              -> Ctype.Void
    | Basic bt          -> Ctype.Basic bt
    | Array ty n        -> Ctype.Array (unproj_ctype ty) n
    | Function ty tys b -> Ctype.Function (unproj_ctype ty) (List.map (Product.make Ctype.no_qualifiers -| unproj_ctype) tys) b
    | Pointer ty        -> Ctype.Pointer Ctype.no_qualifiers (unproj_ctype ty)
    | Atomic ty         -> Ctype.Atomic (unproj_ctype ty)
(*
    | STRUCT tag members -> Ail.STRUCT Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | UNION  tag members -> Ail.UNION  Ail.no_qualifiers tag (List.map (fun (a, m) -> (a, unproj_member m)) members)
    | ENUM id            -> Ail.ENUM id
    | ATOMIC ty          -> Ail.ATOMIC (unproj_ctype ty)
    | SIZE_T             -> Ail.SIZE_T
    | INTPTR_T           -> Ail.INTPTR_T
    | WCHAR_T            -> Ail.WCHAR_T
    | CHAR16_T           -> Ail.CHAR16_T
    | CHAR32_T           -> Ail.CHAR32_T
*)
end
*)




(*
let rec mk_wseqs_aux end_e pat_es =
  match pat_es with
    | []               -> end_e
    | (pat, e) :: pat_es' -> Ewseq pat e (mk_wseqs_aux end_e pat_es')
end

val mk_wseqs: expr unit -> list (pattern * expr unit) -> expr unit
let mk_wseqs end_e = function
  | [] ->
      end_e
  | [(_, e)] ->
      e
  | pat_es ->
      mk_wseqs_aux end_e pat_es
end
*)

(*val maybe_annotate_integer_type : ctype -> expr unit -> expr unit*)
let maybe_annotate_integer_type (Ctype( _, ty_)) (Expr( annots1, expr_)) =
   (let annots1 = ((match ty_ with
    | Basic (Integer ity) -> Avalue (Ainteger ity) :: annots1
    | _ -> annots1
  )) in
  Expr( annots1, expr_))

(*val     mk_sseqs: list (pattern * expr unit) -> (expr unit -> expr unit)*)
let rec mk_sseqs pat_es =
   (fun z ->
  (match pat_es with
    | [] ->
        z
    | (pat, e) :: pat_es' ->
        Expr( [], (Esseq( pat, e, (mk_sseqs pat_es' z))))
  ))



(*
(* val     mk_sseq: forall 'a. list (pattern * expr 'a) -> expr 'a *)
let rec mk_sseq a_opts_es =
  match a_opts_es with
    | []               -> Eskip
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq es')
end

(* val     mk_sseq': forall 'a. list (pattern * expr 'a) -> expr 'a -> expr 'a *)
let rec mk_sseq' a_opts_es z =
  match a_opts_es with
    | []               -> z
    | [(_, e)]         -> e
    | (a_opts, e)::es' -> Esseq a_opts e (mk_sseq' es' z)
end
*)


let mk_unseq =  ((function
  | []  -> Expr( [], (Epure (Pexpr( [], (), (PEval Vunit)))))
  | [e] -> e
  | es  -> Expr( [], (Eunseq es))
))

(*val     mk_unit_sseq: list (expr unit) -> (expr unit -> expr unit)*)
let rec mk_unit_sseq es =
   (fun z ->
    (match es with
      | [] ->
          z
(*
      | [e] ->
          e
*)
      | e::es' ->
          Expr( [], (Esseq( (mk_empty_pat BTy_unit), e, (mk_unit_sseq es' z))))
    ))


let rec concat_sseq (((Expr( annot1, e_)) as e)) e' =
    ((match e_ with
     | Esseq( pat, e1, e2)                 -> Expr( annot1, (Esseq( pat, e1, (concat_sseq e2 e'))))
     | Epure (Pexpr( _, _, (PEval Vunit))) -> e'
     | _                               -> Expr( [], (Esseq( (mk_empty_pat BTy_unit), e, e')))
  ))


(*val valueFromPexpr: pexpr -> maybe value*)
let valueFromPexpr =  ((function
  | Pexpr( _, (), (PEval cval)) ->
      Some ((*flatten_constrained_value*) cval)
  | _ ->
      None
  ))

(*val valueFromPexprs: list pexpr -> maybe (list value)*)
let valueFromPexprs pes =
   (List.fold_right (fun pe acc_opt ->
    (match (valueFromPexpr pe, acc_opt) with
      | (Some cval, Some acc) ->
          Some (cval :: acc)
      | _ ->
          None
    )) pes (Some []))












(* check if a symbolic names is part of a pattern *)
(*val in_pattern: Symbol.sym -> pattern -> bool*)
let rec in_pattern sym1 (Pattern( _, pat)) =
   ((match pat with
    | CaseBase (sym_opt, _) ->
        Lem.option_case false (fun sym' -> (match (sym1, sym') with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  )) sym_opt
    | CaseCtor( _, pats') ->
        List.exists (in_pattern sym1) pats'
  ))





(*val     subst_sym_pexpr: Symbol.sym -> value -> pexpr -> pexpr*)
let rec subst_sym_pexpr sym1 cval (Pexpr( annot1, bty, pexpr_)) =
   (Pexpr( annot1, bty, (match pexpr_ with
    | PEsym sym' ->
        if (match (sym1, sym') with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  ) then PEval cval else pexpr_
    | PEimpl _ ->
        pexpr_
    | PEval _ ->
        pexpr_
    | PEundef( _, _) ->
        pexpr_
    | PEerror( str, pe) ->
        PEerror( str, (subst_sym_pexpr sym1 cval pe))
    | PEctor( ctor1, pes) ->
        PEctor( ctor1, (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | PEcase( pe, xs) ->
        PEcase( (subst_sym_pexpr sym1 cval pe), (Lem_list.map (fun (pat, pe) ->
          (pat, (if in_pattern sym1 pat then pe else subst_sym_pexpr sym1 cval pe))
        ) xs))
    | PEarray_shift( pe1, ty1, pe2) ->
        PEarray_shift( (subst_sym_pexpr sym1 cval pe1), ty1, (subst_sym_pexpr sym1 cval pe2))
    | PEmember_shift( pe, tag_sym, memb_ident) ->
        PEmember_shift( (subst_sym_pexpr sym1 cval pe), tag_sym, memb_ident)
    | PEmemop( mop, pes) ->
        PEmemop( mop, (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | PEnot pe ->
        PEnot (subst_sym_pexpr sym1 cval pe)
    | PEop( bop, pe1, pe2) ->
        PEop( bop, (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2))
    | PEconv_int( ty1, pe) ->
        PEconv_int( ty1, (subst_sym_pexpr sym1 cval pe))
    | PEwrapI( ty1, iop1, pe1, pe2) ->
        PEwrapI( ty1, iop1, (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2))
    | PEcatch_exceptional_condition( ty1, iop1, pe1, pe2) ->
        PEcatch_exceptional_condition( ty1, iop1, (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2))
    | PEstruct( tag_sym, xs) ->
        PEstruct( tag_sym, (Lem_list.map (fun (ident, pe) -> (ident, subst_sym_pexpr sym1 cval pe)) xs))
    | PEunion( tag_sym, ident, pe) ->
        PEunion( tag_sym, ident, (subst_sym_pexpr sym1 cval pe))
    | PEcfunction pe ->
        PEcfunction (subst_sym_pexpr sym1 cval pe)
    | PEmemberof( tag_sym, memb_ident, pe) ->
        PEmemberof( tag_sym, memb_ident, (subst_sym_pexpr sym1 cval pe))
    | PEcall( nm, pes) ->
        PEcall( nm, (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | PElet( pat, pe1, pe2) ->
        PElet( pat, (subst_sym_pexpr sym1 cval pe1), (if in_pattern sym1 pat then pe2 else subst_sym_pexpr sym1 cval pe2))
    | PEif( pe1, pe2, pe3) ->
        PEif( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), (subst_sym_pexpr sym1 cval pe3))
    | PEis_scalar pe ->
        PEis_scalar (subst_sym_pexpr sym1 cval pe)
    | PEis_integer pe ->
        PEis_integer (subst_sym_pexpr sym1 cval pe)
    | PEis_signed pe ->
        PEis_signed (subst_sym_pexpr sym1 cval pe)
    | PEis_unsigned pe ->
        PEis_unsigned (subst_sym_pexpr sym1 cval pe)
    | PEbmc_assume pe ->
        PEbmc_assume (subst_sym_pexpr sym1 cval pe)
    | PEare_compatible( pe1, pe2) ->
        PEare_compatible( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2))
)))


(*val     subst_sym_expr: forall 'a. Symbol.sym -> value -> expr 'a -> expr 'a*)
let rec subst_sym_expr sym1 cval (Expr( annot1, expr_)) =
   (Expr( annot1, (match expr_ with
    | Epure pe ->
        Epure (subst_sym_pexpr sym1 cval pe)
    | Ememop( memop1, pes) ->
        Ememop( memop1, (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | Elet( pat, pe1, e2) ->
        Elet( pat, (subst_sym_pexpr sym1 cval pe1),
          (if in_pattern sym1 pat then e2 else subst_sym_expr sym1 cval e2))
    | Eif( pe1, e2, e3) ->
        Eif( (subst_sym_pexpr sym1 cval pe1),
          (subst_sym_expr sym1 cval e2), (subst_sym_expr sym1 cval e3))
    | Ecase( pe, pat_es) ->
        Ecase( (subst_sym_pexpr sym1 cval pe), (Lem_list.map (fun (pat, e) ->
          (pat, (if in_pattern sym1 pat then e else subst_sym_expr sym1 cval e))
        ) pat_es))
    | Eccall( annot1, pe1, pe2, pes) ->
        Eccall( annot1, (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
          (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | Eproc( annot1, nm, pes) ->
        Eproc( annot1, nm, (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | Eaction pact ->
        Eaction (subst_sym_paction sym1 cval pact)
    | Eunseq es ->
        Eunseq (Lem_list.map (subst_sym_expr sym1 cval) es)
    | Ewseq( pat, e1, e2) ->
        Ewseq( pat, (subst_sym_expr sym1 cval e1),
          (if in_pattern sym1 pat then e2 else subst_sym_expr sym1 cval e2))
    | Esseq( pat, e1, e2) ->
        Esseq( pat, (subst_sym_expr sym1 cval e1),
          (if in_pattern sym1 pat then e2 else subst_sym_expr sym1 cval e2))
    | Ebound e ->
        Ebound (subst_sym_expr sym1 cval e)
    | Esave( lab_sym, sym_bTy_pes, e) ->
        let sym_bTy_pes' = (Lem_list.map (fun (z, (bTy, pe)) ->
          (z, (bTy, subst_sym_pexpr sym1 cval pe))
        ) sym_bTy_pes) in
        if List.exists (fun (z, _) -> (match (sym1, z) with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  )) sym_bTy_pes then
          let () = (Cerb_debug.warn [] (fun () -> "subst, Esave ==> shadowing")) in
          (* TODO: check *)
          Esave( lab_sym, sym_bTy_pes', e) 
        else
          Esave( lab_sym, sym_bTy_pes', (subst_sym_expr sym1 cval e))
    | Erun( annot1, lab_sym, pes) ->
        Erun( annot1, lab_sym, (Lem_list.map (subst_sym_pexpr sym1 cval) pes))
    | End es ->
        End (Lem_list.map (subst_sym_expr sym1 cval) es)
    | Epar es ->
        Epar (Lem_list.map (subst_sym_expr sym1 cval) es)
    | Ewait _ ->
      expr_
    | Eannot( xs, e) ->
        Eannot( xs, (subst_sym_expr sym1 cval e))
    | Eexcluded( n, act) ->
        Eexcluded( n, (subst_sym_action sym1 cval act))
(*
    | Eloc loc e ->
        Eloc loc (subst_sym_expr sym cval e)
    | Estd str e ->
        Estd str (subst_sym_expr sym cval e)
*)
  )))

and subst_sym_action_ sym1 cval =  ((function
  | Create( pe1, pe2, pref) ->
      Create( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), pref)
  | CreateReadOnly( pe1, pe2, pe3, pref) ->
      CreateReadOnly( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), (subst_sym_pexpr sym1 cval pe3), pref)
  | Alloc0( pe1, pe2, pref) ->
      Alloc0( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), pref)
  | Kill( kind1, pe) ->
      Kill( kind1, (subst_sym_pexpr sym1 cval pe))
  | Store0( b, pe1, pe2, pe3, mo1) ->
      Store0( b, (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
        (subst_sym_pexpr sym1 cval pe3), mo1)
  | Load0( pe1, pe2, mo1) ->
      Load0( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), mo1)
  | SeqRMW( b, pe1, pe2, sym', pe3) ->
      SeqRMW( b, (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), sym',
        begin
          if (match (sym1, sym') with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  ) then pe3 else subst_sym_pexpr sym1 cval pe3
        end)
  | RMW0( pe1, pe2, pe3, pe4, mo1, mo2) ->
      RMW0( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
        (subst_sym_pexpr sym1 cval pe3), (subst_sym_pexpr sym1 cval pe4), mo1, mo2)
  | Fence0 mo1 ->
      Fence0 mo1
  | CompareExchangeStrong( pe1, pe2, pe3, pe4, mo1, mo2) ->
      CompareExchangeStrong( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
        (subst_sym_pexpr sym1 cval pe3), (subst_sym_pexpr sym1 cval pe4), mo1, mo2)
  | CompareExchangeWeak( pe1, pe2, pe3, pe4, mo1, mo2) ->
      CompareExchangeWeak( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
        (subst_sym_pexpr sym1 cval pe3), (subst_sym_pexpr sym1 cval pe4), mo1, mo2)
  | LinuxFence mo1 ->
      LinuxFence mo1
  | LinuxStore( pe1, pe2, pe3, mo1) ->
      LinuxStore( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
        (subst_sym_pexpr sym1 cval pe3), mo1)
  | LinuxLoad( pe1, pe2, mo1) ->
      LinuxLoad( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2), mo1)
  | LinuxRMW( pe1, pe2, pe3, mo1) ->
      LinuxRMW( (subst_sym_pexpr sym1 cval pe1), (subst_sym_pexpr sym1 cval pe2),
        (subst_sym_pexpr sym1 cval pe3), mo1)
))
and subst_sym_action sym1 cval (Action( loc1, bs, act_)) =
   (Action( loc1, bs, (subst_sym_action_ sym1 cval act_)))
and subst_sym_paction sym1 cval (Paction( p, act)) =
   (Paction( p, (subst_sym_action sym1 cval act)))



(*val     subst_pattern_val: forall 'a. pattern -> value -> expr 'a -> expr 'a*)
let rec subst_pattern_val (Pattern( _, pat)) cval expr1 =
   (
  (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)(match (pat, cval) with
    | (CaseBase (None, _), _) ->
        (* e[_ \ v] = e *)
        expr1
    | (CaseBase (Some sym1, _), _) ->
        (* e[sym \ v] *)
        subst_sym_expr sym1 cval expr1
    | (CaseCtor( (Cnil _), []), Vlist( _, [])) ->
        (* empty list (value) *)
        expr1
    | (CaseCtor( Ccons, [pat1; pat2]), Vlist( bTy_elem, (cval1::cvals))) ->
        (* populated list (value) *) subst_pattern_val pat1 cval1 (subst_pattern_val pat2 (Vlist( bTy_elem, cvals)) expr1)
    | (CaseCtor( Ctuple, pats'), Vtuple cvals) ->
        List.fold_right (fun (pat', cval') acc ->
          subst_pattern_val pat' cval' acc
        ) (Lem_list.list_combine pats' cvals) expr1
    | (CaseCtor( Cspecified, [pat']), Vloaded (LVspecified oval)) ->
        subst_pattern_val pat' (Vobject oval) expr1
    | (CaseCtor( Cunspecified, [pat']), Vloaded (LVunspecified ty1)) ->
        subst_pattern_val pat' (Vctype ty1) expr1
    | (CaseCtor( ctor1, pats), _) ->
        let str_ctor = ((match ctor1 with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
          | CivNULLcap is_signed ->
              "ivNULLcap(" ^ (if is_signed then "signed" else "unsigned" ^ ")")
        )) in
        Cerb_debug.error ("WIP: Core_aux.subst_pattern_val ==> ctor= " ^ (str_ctor ^ (", |pats|= "
               ^ ((string_of_int (List.length pats)) ^ (" -- " ^ String_core.string_of_value cval)))))
  ))


























(* substitute in an expression a symbolic name with a (pure) expression *)
(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
(*val     unsafe_subst_sym_pexpr: Symbol.sym -> pexpr -> pexpr -> pexpr*)
let rec unsafe_subst_sym_pexpr sym1 ((Pexpr( annot1, bty, pe_') as pe')) (Pexpr( _, _, pe_)) =
   (Pexpr( annot1, bty, (match pe_ with
    | PEsym sym' ->
        if (match (sym1, sym') with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  ) then pe_' else pe_
    | PEimpl _ ->
        pe_
    | PEval _ ->
        pe_
    | PEundef( _, _) ->
        pe_
    | PEerror( str, pe) ->
        PEerror( str, (unsafe_subst_sym_pexpr sym1 pe' pe))
    | PEctor( ctor1, pes) ->
        PEctor( ctor1, (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | PEcase( pe, xs) ->
        PEcase( (unsafe_subst_sym_pexpr sym1 pe' pe), (Lem_list.map (fun (pat, pe) ->
          (pat, (if in_pattern sym1 pat then pe else unsafe_subst_sym_pexpr sym1 pe' pe))
        ) xs))
    | PEarray_shift( pe1, ty1, pe2) ->
        PEarray_shift( (unsafe_subst_sym_pexpr sym1 pe' pe1), ty1, (unsafe_subst_sym_pexpr sym1 pe' pe2))
    | PEmember_shift( pe, tag_sym, memb_ident) ->
        PEmember_shift( (unsafe_subst_sym_pexpr sym1 pe' pe), tag_sym, memb_ident)
    | PEmemop( mop, pes) ->
        PEmemop( mop, (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | PEnot pe ->
        PEnot (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEop( bop, pe1, pe2) ->
        PEop( bop, (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_pexpr sym1 pe' pe2))
    | PEconv_int( ty1, pe) ->
        PEconv_int( ty1, (unsafe_subst_sym_pexpr sym1 pe' pe))
    | PEwrapI( ty1, iop1, pe1, pe2) ->
        PEwrapI( ty1, iop1, (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_pexpr sym1 pe' pe2))
    | PEcatch_exceptional_condition( ty1, iop1, pe1, pe2) ->
        PEcatch_exceptional_condition( ty1, iop1, (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_pexpr sym1 pe' pe2))
    | PEstruct( tag_sym, xs) ->
        PEstruct( tag_sym, (Lem_list.map (fun (ident, pe) -> (ident, unsafe_subst_sym_pexpr sym1 pe' pe)) xs))
    | PEunion( tag_sym, ident, pe) ->
        PEunion( tag_sym, ident, (unsafe_subst_sym_pexpr sym1 pe' pe))
    | PEcfunction pe ->
        PEcfunction (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEmemberof( tag_sym, memb_ident, pe) ->
        PEmemberof( tag_sym, memb_ident, (unsafe_subst_sym_pexpr sym1 pe' pe))
    | PEcall( nm, pes) ->
        PEcall( nm, (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | PElet( pat, pe1, pe2) ->
        PElet( pat, (unsafe_subst_sym_pexpr sym1 pe' pe1), (if in_pattern sym1 pat then pe2 else unsafe_subst_sym_pexpr sym1 pe' pe2))
    | PEif( pe1, pe2, pe3) ->
        PEif( (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_pexpr sym1 pe' pe2), (unsafe_subst_sym_pexpr sym1 pe' pe3))
    | PEis_scalar pe ->
        PEis_scalar (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEis_integer pe ->
        PEis_integer (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEis_signed pe ->
        PEis_signed (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEis_unsigned pe ->
        PEis_unsigned (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEbmc_assume pe ->
        PEbmc_assume (unsafe_subst_sym_pexpr sym1 pe' pe)
    | PEare_compatible( pe1, pe2) ->
        PEare_compatible( (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_pexpr sym1 pe' pe2))
)))


(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
(*val     unsafe_subst_sym_expr: forall 'a. Symbol.sym -> pexpr -> expr 'a -> expr 'a*)
let rec unsafe_subst_sym_expr sym1 pe' (Expr( annot1, expr_)) =
   (Expr( annot1, (match expr_ with
    | Epure pe ->
        Epure (unsafe_subst_sym_pexpr sym1 pe' pe)
    | Ememop( memop1, pes) ->
        Ememop( memop1, (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | Elet( pat, pe1, e2) ->
        Elet( pat, (unsafe_subst_sym_pexpr sym1 pe' pe1), (if in_pattern sym1 pat then e2 else unsafe_subst_sym_expr sym1 pe' e2))
    | Eif( pe1, e2, e3) ->
        Eif( (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_expr sym1 pe' e2), (unsafe_subst_sym_expr sym1 pe' e3))
    | Ecase( pe, pat_es) ->
        Ecase( (unsafe_subst_sym_pexpr sym1 pe' pe), (Lem_list.map (fun (pat, e) ->
          (pat, (if in_pattern sym1 pat then e else unsafe_subst_sym_expr sym1 pe' e))
        ) pat_es))
    | Eccall( annot1, pe1, pe2, pes) ->
        Eccall( annot1, (unsafe_subst_sym_pexpr sym1 pe' pe1), (unsafe_subst_sym_pexpr sym1 pe' pe2),
          (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | Eproc( annot1, nm, pes) ->
        Eproc( annot1, nm, (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | Eaction pact ->
        Eaction (unsafe_subst_sym_paction sym1 pe' pact)
    | Eunseq es ->
        Eunseq (Lem_list.map (unsafe_subst_sym_expr sym1 pe') es)
    | Ewseq( pat, e1, e2) ->
        Ewseq( pat, (unsafe_subst_sym_expr sym1 pe' e1), (if in_pattern sym1 pat then e2 else unsafe_subst_sym_expr sym1 pe' e2))
    | Esseq( pat, e1, e2) ->
        Esseq( pat, (unsafe_subst_sym_expr sym1 pe' e1), (if in_pattern sym1 pat then e2 else unsafe_subst_sym_expr sym1 pe' e2))
    | Ebound e ->
        Ebound (unsafe_subst_sym_expr sym1 pe' e)
    | Esave( lab_sym, sym_bTy_pes, e) ->
        let sym_bTy_pes' = (Lem_list.map (fun (z, (bTy, pe)) ->
          (z, (bTy, unsafe_subst_sym_pexpr sym1 pe' pe))
        ) sym_bTy_pes) in
        if List.exists (fun (z, _) -> (match (sym1, z) with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  )) sym_bTy_pes then
          let () = (Cerb_debug.warn [] (fun () -> "unsafe_subst, Esave ==> shadowing")) in
          (* TODO: check *)
          Esave( lab_sym, sym_bTy_pes', e) 
        else
          Esave( lab_sym, sym_bTy_pes', (unsafe_subst_sym_expr sym1 pe' e))
    | Erun( annot1, lab_sym, pes) ->
        Erun( annot1, lab_sym, (Lem_list.map (unsafe_subst_sym_pexpr sym1 pe') pes))
    | End es ->
        End (Lem_list.map (unsafe_subst_sym_expr sym1 pe') es)
    | Epar es ->
        Epar (Lem_list.map (unsafe_subst_sym_expr sym1 pe') es)
    | Ewait _ ->
        expr_
    | Eannot( xs, e) ->
        Eannot( xs, (unsafe_subst_sym_expr sym1 pe' e))
    | Eexcluded( n, act) ->
        Eexcluded( n, (unsafe_subst_sym_action sym1 pe' act))

(*
    | Eloc loc e ->
        Eloc loc (unsafe_subst_sym_expr sym pe' e)
    | Estd s e ->
        Estd s (unsafe_subst_sym_expr sym pe' e)
*)
  )))


(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
and unsafe_subst_sym_action_ a pe' =  ((function
  | Create( pe1, pe2, pref) ->
      Create( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), pref)
  | CreateReadOnly( pe1, pe2, pe3, pref) ->
      CreateReadOnly( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), (unsafe_subst_sym_pexpr a pe' pe3), pref)
  | Alloc0( pe1, pe2, pref) ->
      Alloc0( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), pref)
  | Kill( kind1, pe) ->
      Kill( kind1, (unsafe_subst_sym_pexpr a pe' pe))
  | Store0( b, pe1, pe2, pe3, mo1) ->
      Store0( b, (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2),
        (unsafe_subst_sym_pexpr a pe' pe3), mo1)
  | Load0( pe1, pe2, mo1) ->
      Load0( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), mo1)
  | SeqRMW( b, pe1, pe2, sym', pe3) ->
      SeqRMW( b, (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), sym',
        begin
          if (match (a, sym') with
    | (Symbol.Symbol( d1, n1, sd1), Symbol.Symbol( d2, n2, sd2)) ->
        if (Digest.compare d1 d2 = 0) && (n1 = n2) then
          if (Cerb_debug.get_debug_level () >= 5) && unsafe_structural_inequality sd1 sd2 then
            let () = (Cerb_debug.print_debug 5 [] (fun () ->
              "[Symbol.symbolEqual] suspicious equality ==> " ^ (Symbol.show_symbol_description sd1
              ^ (" <-> " ^ Symbol.show_symbol_description sd2)))) in
            true
          else
            true
        else
          false
  ) then pe3 else unsafe_subst_sym_pexpr a pe' pe3
        end)
  | RMW0( pe1, pe2, pe3, pe4, mo1, mo2) ->
      RMW0( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2),
        (unsafe_subst_sym_pexpr a pe' pe3), (unsafe_subst_sym_pexpr a pe' pe4), mo1, mo2)
  | Fence0 mo1 ->
      Fence0 mo1
  | CompareExchangeStrong( pe1, pe2, pe3, pe4, mo1, mo2) ->
      CompareExchangeStrong( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), (unsafe_subst_sym_pexpr a pe' pe3), (unsafe_subst_sym_pexpr a pe' pe4), mo1, mo2)
  | CompareExchangeWeak( pe1, pe2, pe3, pe4, mo1, mo2) ->
      CompareExchangeWeak( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), (unsafe_subst_sym_pexpr a pe' pe3), (unsafe_subst_sym_pexpr a pe' pe4), mo1, mo2)
  | LinuxFence mo1 ->
      LinuxFence mo1
  | LinuxStore( pe1, pe2, pe3, mo1) ->
      LinuxStore( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2),
        (unsafe_subst_sym_pexpr a pe' pe3), mo1)
  | LinuxLoad( pe1, pe2, mo1) ->
      LinuxLoad( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2), mo1)
  | LinuxRMW( pe1, pe2, pe3, mo1) ->
      LinuxRMW( (unsafe_subst_sym_pexpr a pe' pe1), (unsafe_subst_sym_pexpr a pe' pe2),
        (unsafe_subst_sym_pexpr a pe' pe3), mo1)


(*
  | CompareExchangeWeak pe1 pe2 pe3 pe4 mo1 mo2 ->
        CompareExchangeWeak (unsafe_subst_sym_pexpr a pe' pe1) (unsafe_subst_sym_pexpr a pe' pe2) (unsafe_subst_sym_pexpr a pe' pe3) (unsafe_subst_sym_pexpr a pe' pe4) mo1 mo2
*)
  ))
and unsafe_subst_sym_action a pe' (Action( loc1, bs, act_)) =
   (Action( loc1, bs, (unsafe_subst_sym_action_ a pe' act_)))
and unsafe_subst_sym_paction a pe' (Paction( p, act)) =
   (Paction( p, (unsafe_subst_sym_action a pe' act)))

(* TODO: [unsafe_subst_pattern _as v e] substitute the symbols _as with the corresponding
   of the value expression [v] in the expression [e]. This function leads
   to a crash if [v] is not a value or its type doesn't match the symbolic
   pattern *)
(* NOTE: this is usually unsound to use if pe' doesn't evaluate to a defined value or generates memory constraints *)
(*val     unsafe_subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> expr 'a*)
let rec unsafe_subst_pattern (Pattern( _, pat)) pe' expr1 =
  
   ((match (pat, pe') with
    | (CaseBase (None, _), _) ->
        expr1
    | (CaseBase (Some sym1, _), _) ->
        unsafe_subst_sym_expr sym1 pe' expr1
    | (CaseCtor( (Cnil _), []), Pexpr( _, _, (PEval (Vlist( _, []))))) ->
        (* empty list (value) *)
        expr1
    | (CaseCtor( (Cnil _), []), Pexpr( _, _, (PEctor( (Cnil _), [])))) ->
        (* empty list (pure expr) *)
        expr1
    | (CaseCtor( Ccons, [pat1; pat2]), Pexpr( _, (), (PEval (Vlist( bTy_elem, (cval::cvals)))))) ->
        (* populated list (value) *) subst_pattern_val pat1 cval (subst_pattern_val pat2 (Vlist( bTy_elem, cvals)) expr1)
    | (CaseCtor( Ccons, [pat1; pat2]), Pexpr( _, _, (PEctor( Ccons, [pe1; pe2])))) ->
        (* populated list (pure expr) *) unsafe_subst_pattern pat1 pe1 (unsafe_subst_pattern pat2 pe2 expr1)
    | (CaseCtor( Ctuple, pats'), Pexpr( _, (), (PEval (Vtuple cvals)))) ->
        List.fold_right (fun (pat', cval) acc ->
          subst_pattern_val pat' cval acc
        ) (Lem_list.list_combine pats' cvals) expr1
    | (CaseCtor( Ctuple, pats'), Pexpr( _, _, (PEctor( Ctuple, pes)))) ->
        List.fold_right (fun (pat', pe) acc ->
          unsafe_subst_pattern pat' pe acc
        ) (Lem_list.list_combine pats' pes) expr1
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor( Cspecified, [pat']), Pexpr( _, (), (PEval (Vloaded (LVspecified oval))))) ->
        subst_pattern_val pat' (Vobject oval) expr1
    | (CaseCtor( Cspecified, [pat']), Pexpr( _, (), (PEctor( Cspecified, [pe''])))) ->
        unsafe_subst_pattern pat' pe'' expr1
    | (CaseCtor( Cunspecified, [pat']), Pexpr( _, (), (PEval (Vloaded (LVunspecified ty1))))) ->
        subst_pattern_val pat' (Vctype ty1) expr1
    | (CaseCtor( Cunspecified, [pat']), Pexpr( _, (), (PEctor( Cunspecified, [pe''])))) ->
        unsafe_subst_pattern pat' pe'' expr1
    | (CaseCtor( ctor1, pats), _) ->
        let str_ctor = ((match ctor1 with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
          | CivNULLcap is_signed ->
              "ivNULLcap(" ^ (if is_signed then "signed" else "unsigned" ^ ")")  
        )) in
        Cerb_debug.error ("WIP: Core_aux.unsafe_subst_pattern ==> ctor= " ^ (str_ctor ^ (", |pats|= "
               ^ ((string_of_int (List.length pats)) ^ (" -- " ^ String_core.string_of_pexpr pe')))))
  ))

(*val     subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> maybe (expr 'a)*)
let rec subst_pattern (Pattern( _, pat)) pe' expr1 =
  
   ((match (pat, pe') with
    | (CaseBase (None, _), _) ->
        Some expr1
    | (CaseBase (Some sym1, _), _) -> Some (unsafe_subst_sym_expr sym1 pe' expr1)
    | (CaseCtor( (Cnil _), []), Pexpr( _, _, (PEval (Vlist( _, []))))) ->
        (* empty list (value) *)
        Some expr1
    | (CaseCtor( (Cnil _), []), Pexpr( _, _, (PEctor( (Cnil _), [])))) ->
        (* empty list (pure expr) *)
        Some expr1
    | (CaseCtor( Ccons, [pat1; pat2]), Pexpr( _, (), (PEval (Vlist( bTy_elem, (cval::cvals)))))) ->
        (* populated list (value) *)
        Some ( subst_pattern_val pat1 cval (subst_pattern_val pat2 (Vlist( bTy_elem, cvals)) expr1))
    | (CaseCtor( Ccons, [pat1; pat2]), Pexpr( _, _, (PEctor( Ccons, [pe1; pe2])))) ->
        (* populated list (pure expr) *)
        (match subst_pattern pat2 pe2 expr1 with
          | Some e -> subst_pattern pat1 pe1 e
          | None -> None
        )
    | (CaseCtor( Ctuple, pats'), Pexpr( _, (), (PEval (Vtuple cvals)))) -> Some (List.fold_right (fun (pat', cval) acc ->
          subst_pattern_val pat' cval acc
        ) (Lem_list.list_combine pats' cvals) expr1)
    | (CaseCtor( Ctuple, pats'), Pexpr( _, _, (PEctor( Ctuple, pes)))) ->
        List.fold_right (fun (pat', pe) acc ->
          (match acc with
            | Some e -> subst_pattern pat' pe e
            | None -> None
          )
        ) (Lem_list.list_combine pats' pes) (Some expr1)
    (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)
    
    | (CaseCtor( Cspecified, [pat']), Pexpr( _, (), (PEval (Vloaded (LVspecified oval))))) -> Some (subst_pattern_val pat' (Vobject oval) expr1)
    | (CaseCtor( Cspecified, [pat']), Pexpr( _, (), (PEctor( Cspecified, [pe''])))) ->
        subst_pattern pat' pe'' expr1
    | (CaseCtor( Cunspecified, [pat']), Pexpr( _, (), (PEval (Vloaded (LVunspecified ty1))))) -> Some (subst_pattern_val pat' (Vctype ty1) expr1)
    | (CaseCtor( Cunspecified, [pat']), Pexpr( _, (), (PEctor( Cunspecified, [pe''])))) ->
        subst_pattern pat' pe'' expr1
    | (CaseCtor( ctor1, pats), _) ->
        None
  ))



(*val     to_pure: forall 'a. expr 'a -> maybe pexpr*)
let rec to_pure (Expr( annot1, expr_)) = (
   (*(expr : expr 'a)*)let to_pure_aux pat pe1 e2=
     ((match subst_pattern pat pe1 e2 with
      | Some e -> to_pure e
      | None ->
          (match to_pure e2 with
            | None ->
                None
            | Some pe2 ->
                Some (Pexpr( [], (), (PElet( pat, pe1, pe2))))
          )
    ))
  in
  (match expr_ with
    | Epure pe ->
        Some pe
    | Ememop( _, _) ->
        None
    | Elet( pat, pe1, e2) ->
        (match to_pure e2 with
          | Some ((Pexpr( annot1, bTy, _) as pe2)) ->
              Some (Pexpr( annot1, bTy, (PElet( pat, pe1, pe2))))
          | _ ->
              None
        )
    | Eif( pe1, e2, e3) ->
        (match (to_pure e2, to_pure e3) with
          | (Some ((Pexpr( annot1, bTy, _) as pe2)), Some pe3) ->
              Some (Pexpr( annot1, bTy, (PEif( pe1, pe2, pe3))))
          | _ ->
              None
        )
    | Eccall( _, _, _, _) ->
        None
    | Eproc( _, _, _) ->
        None
    | Eaction _ ->
        None
    | Eunseq es ->
        (match to_pures es with
          | Some pes ->
              Some (Pexpr( [], (), (PEctor( Ctuple, pes))))
          | None ->
              None
        )
    | Ewseq( pat, e1, e2) ->
        (match to_pure e1 with
          | Some pe1 ->
              to_pure_aux pat pe1 e2
          | None ->
              None
        )
    | Esseq( pat, e1, e2) ->
        (match to_pure e1 with
          | Some pe1 ->
              to_pure_aux pat pe1 e2
          | None ->
              None
        )
    | Ebound e ->
        (* TODO: check *)
        to_pure e
    | Esave( _, _, _) ->
        None
    | Erun( _, _, _) ->
        None
    | End _ ->
        None
    | Epar _ ->
        None
    | Ewait _ ->
        None
    | Eannot( _, _) ->
        Cerb_debug.error "to_pure Eannot"
    | Eexcluded( _, _) ->
        Cerb_debug.error "to_pure Eexcluded"
(*
    | Eloc _ e ->
        to_pure e
    | Estd _ e ->
        to_pure e
*)
    | Ecase( pe, pat_es) ->
       let (pats, es) = (List.split pat_es) in
        (match to_pures es with
          | Some (((Pexpr( annot1, bTy, _) :: _) as pes)) ->
              Some (Pexpr( annot1, bTy, (PEcase( pe, (Lem_list.list_combine pats pes)))))
          | _ ->
            None
        )
))

(* val     to_pures: forall 'a. list (expr 'a) -> maybe (list pexpr)*)
and to_pures es =
   (List.fold_right (fun e acc_opt ->
    (match (to_pure e, acc_opt) with
      | (Some pe, Some acc) ->
          Some (pe :: acc)
      | _ ->
          None
    )) es (Some []))



(*val subst_wait: forall 'a. Mem_common.thread_id -> value -> expr 'a -> expr 'a*)
let rec subst_wait tid1 v (Expr( annot1, expr_)) =
   (Expr( annot1, (match expr_ with
  | Epure _ ->
      expr_
  | Ememop( _, _) ->
      expr_
  | Elet( sym1, pe1, e2) ->
      Elet( sym1, pe1, (subst_wait tid1 v e2))
  | Eif( pe1, e2, e3) ->
      Eif( pe1, (subst_wait tid1 v e2), (subst_wait tid1 v e3))
  | Ecase( pe, pat_es) ->
      Ecase( pe, (Lem_list.map (fun (pat, e) -> (pat, subst_wait tid1 v e)) pat_es))
  | Eccall( _, _, _, _) ->
      expr_
  | Eproc( _, _, _) ->
      expr_
  | Eaction _ ->
      expr_
  | Eunseq es ->
      Eunseq (Lem_list.map (subst_wait tid1 v) es)
   | Ewseq( _as, e1, e2) ->
       Ewseq( _as, (subst_wait tid1 v e1), (subst_wait tid1 v e2))
   | Esseq( _as, e1, e2) ->
       Esseq( _as, (subst_wait tid1 v e1), (subst_wait tid1 v e2))
   | Ebound e ->
       Ebound (subst_wait tid1 v e)
(*
   | Esave ksym sym_tys e ->
       Esave ksym sym_tys (subst_wait tid v e)
   | (Erun _ _ _ as expr) ->
       expr
*)
   | Esave( sym1, sym_bTys, e) ->
       Esave( sym1, sym_bTys, (subst_wait tid1 v e))
   | Erun( _, _, _) ->
       expr_
   | End es ->
       End (Lem_list.map (subst_wait tid1 v) es)
   | Epar es ->
       Epar (Lem_list.map (subst_wait tid1 v) es)
   | Ewait tid' ->
       if tid1 = tid' then
         (match v with
           | Vunit ->
               Epure (Pexpr( [], (), (PEval Vunit)))
           | _ ->
               Epure (Pexpr( [], (), (PEval v)))
         )
       else
         Ewait tid'
   | Eannot( xs, e) ->
       Eannot( xs, (subst_wait tid1 v e))
   | Eexcluded( _, _) ->
       expr_
(*
   | Eloc loc e ->
       Eloc loc (subst_wait tid v e)
   | Estd s e ->
       Estd s (subst_wait tid v e)
*)
)))





let rec find_labeled_continuation sym1 (Expr( annot1, expr_)) =
   ((match expr_ with
    | Epure _ ->
        None
    | Ememop( _, _) ->
        None
    | Eaction _ ->
        None
    | Ecase( _, pat_es) ->
        let () = (Cerb_debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes there is atmost single match inside a Ecase")) in
        List.fold_left (fun acc (_, e) ->
          (match acc with
            | Some _ ->
                acc
            | None ->
                (match find_labeled_continuation sym1 e with
                  | None ->
                      None
                  | Some ret ->
                      Some ret
                )
          )
        ) None pat_es
    | Elet( _, _, e2) ->
        find_labeled_continuation sym1 e2
    | Eif( _, e2, e3) ->
        (* NOTE: in a well formed Core expr, [sym] cannot be bound in both e2 and e3. *)
        (match find_labeled_continuation sym1 e2 with
          | Some z ->
              Some z
          | None ->
              find_labeled_continuation sym1 e3
        )
    | Eccall( _, _, _, _) ->
        None
    | Eproc( _, _, _) ->
        None
    | Eunseq _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside unseq() *)
        None
    | Ewseq( pat, e1, e2) ->
        let () = (Cerb_debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Ewseq don't clash")) in
        (match find_labeled_continuation sym1 e1 with
          | Some (syms, cont_expr) ->
              Some (syms, Expr( annot1, (Ewseq( pat, cont_expr, e2))))
          | None ->
              find_labeled_continuation sym1 e2
        )
    | Esseq( pat, e1, e2) ->
        let () = (Cerb_debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes the bindings of an Esave inside a Esseq don't clash")) in
        (match find_labeled_continuation sym1 e1 with
          | Some (syms, cont_expr) ->
              Some (syms, Expr( annot1, (Esseq( pat, cont_expr, e2))))
          | None ->
              find_labeled_continuation sym1 e2
        )
    | Ebound _ ->
        (* NOTE: Typing forbids labeled continuation bindings inside bound() *)
        None
    | End _ ->
        (* NOTE: Typing forbids labeled continuation bindings in inside nd() *)
        None
    | Esave( (sym', _), sym_bTys, e) ->
        if  Symbol.symbolEquality sym1 sym' then
          Some (Lem_list.map fst sym_bTys, e)
        else
          find_labeled_continuation sym1 e
    | Erun( annot1, sym1, pes) ->
        None
    | Epar es ->
        let () = (Cerb_debug.warn [] (fun () -> "Core_aux.find_labeled_continuation assumes there are no Esave inside par()")) in
        None
    | Ewait _ ->
        None
    | Eannot( _, _) ->
        (* NOTE: Eannot only appear at runtime, and inside an Ebound, where
                 typing forbids labeled continuation bindings. *)
        None
    | Eexcluded( _, _) ->
        (* NOTE: Eexcluded only appear at runtime, and inside an Eexcluded, where
                 typing forbids labeled continuation bindings. *)
        None

(*
    | Eloc _ e ->
        find_labeled_continuation sym e
    | Estd _ e ->
        find_labeled_continuation sym e
*)
  ))

(*
val     has_sseqs: forall 'a. expr 'a -> bool
let rec has_sseqs expr =
  match expr with
    | Epure _ ->
        false
    | Ememop _ _ ->
        false
    | Eaction p ->
        false
    | Ecase _ pat_es ->
        List.any (fun (_, e) -> has_sseqs e) pat_es
    | Elet _ _ e2 ->
        has_sseqs e2
    | Eif _ e2 e3 ->
        has_sseqs e2 || has_sseqs e3
    | Eskip ->
        false
    | Eccall _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eproc _ _ _ ->
        (* TODO: look into the called body *)
        false
    | Eunseq es ->
        List.any has_sseqs es
    | Ewseq _ e1 e2 ->
        has_sseqs e1 || has_sseqs e2
    | Esseq _ _ _ ->
        true
    | Ebound e ->
        has_sseqs e
    | Esave _ _ e ->
        has_sseqs e
    | Erun _ _ _ ->
        false
    | End es ->
        List.any has_sseqs es
    | Epar _ ->
        (* TODO: I think *)
        false
    | Ewait _ ->
        false
    | Eloc _ e ->
        has_sseqs e
  end
*)



(*val     match_pattern: pattern -> value -> maybe (list (Symbol.sym * value))*)
let rec match_pattern (Pattern( _, pat)) cval =
   ((match (pat, cval) with
    | (CaseBase (None, _), _) ->
        Some []
    | (CaseBase (Some sym1, _), _) ->
        Some [(sym1, cval)]
(*      | Vobject of (generic_object_value 'sym) *)
    | (CaseCtor( Cspecified, [pat']), Vloaded (LVspecified oval)) ->
        match_pattern pat' (Vobject oval)
    | (CaseCtor( Cunspecified, [pat']), Vloaded (LVunspecified ty1)) ->
        match_pattern pat' (Vctype ty1)
(*      | Vlist of core_base_type * list (generic_value 'sym) *)
    | (CaseCtor( Ctuple, pats'), Vtuple cvals') -> 
        List.fold_right (fun (pat', cval') acc ->
          Lem.option_bind acc (fun xs ->
            Lem.option_bind (match_pattern pat' cval') (fun x ->
              Some (List.rev_append (List.rev x) xs)
            )
          )
        ) (Lem_list.list_combine pats' cvals') (Some [])
    | (CaseCtor( (Cnil _), []), Vlist( _, [])) ->
        let () = (Cerb_debug.warn [] (fun () -> "Pattern matching nil without checking types!")) in
        Some []
    | (CaseCtor( Ccons, [pat_x; pat_xs]), Vlist( ty1, (x::xs))) ->
        Lem.option_bind (match_pattern pat_x x) (fun x ->
          Lem.option_bind (match_pattern pat_xs (Vlist( ty1, xs))) (fun xs ->
            Some (List.rev_append (List.rev x) xs)
          )
        )
    | _ ->
        None
  ))

(*val     select_case: forall 'a. (Symbol.sym -> value -> 'a -> 'a) -> value -> list (pattern * 'a) -> maybe 'a*)
let rec select_case subst_sym cval =  ((function
  | [] ->
      None
  | (pat, pe) :: pat_pes' ->
      (match match_pattern pat cval with
        | None ->
            (* trying the next branch *)
            select_case subst_sym cval pat_pes'
        | Some (sym_cvals) -> Some (List.fold_right (fun (sym1, cval') acc ->
              subst_sym sym1 cval' acc
            ) sym_cvals pe)
      )
))


(*
val isConstrainedValue: value -> bool
let isConstrainedValue cval =
  match flatten_constrained_value cval with
    | Vconstrained _ ->
        true
    | _ ->
        false
  end
*)

(*val mk_pure_e: forall 'a. pexpr -> expr 'a*)
let mk_pure_e pe =
   (Expr( [], (Epure pe)))

(*val mk_value_e: forall 'a. value -> expr 'a*)
let mk_value_e cval =
   (mk_pure_e (mk_value_pe cval))

(*val mk_skip_e: expr unit*)
let mk_skip_e =
   (Expr( [], (Epure (Pexpr( [], (), (PEval Vunit))))))


(*val mk_unseq_e: forall 'a. list (expr 'a) -> expr 'a*)
let mk_unseq_e es =
   (Expr( [], (Eunseq es)))

(*val mk_case_e: pexpr -> list (pattern * expr unit) -> expr unit*)
let mk_case_e pe pat_es =
   (Expr( [], (Ecase( pe, pat_es))))

(*val mk_wseq_e: forall 'a. pattern -> expr 'a -> expr 'a -> expr 'a*)
let mk_wseq_e pat e1 e2 =
   (Expr( [], (Ewseq( pat, e1, e2))))

(*val mk_sseq_e: forall 'a. pattern -> expr 'a -> expr 'a -> expr 'a*)
let mk_sseq_e pat e1 e2 =
   (Expr( [], (Esseq( pat, e1, e2))))

(*val mk_save_e_: list annot -> (Symbol.sym * core_base_type) -> list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) -> expr unit -> expr unit*)
let mk_save_e_ annots1 sym_ty sym_ty_pes e =
   (Expr( annots1, (Esave( sym_ty, sym_ty_pes, e))))

(*
val mk_save_e: (Symbol.sym * core_base_type) -> list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) -> expr unit -> expr unit
let mk_save_e sym_ty sym_ty_pes e =
  Expr [] (Esave sym_ty sym_ty_pes e)
*)

(*val mk_run_e: Symbol.sym -> list pexpr -> expr unit*)
let mk_run_e sym1 pes =
   (Expr( [], (Erun( (), sym1, pes))))

(*val mk_nd_e: list (expr unit) -> expr unit*)
let mk_nd_e es =
   (Expr( [], (End es)))

(*val mk_if_e_: list annot -> pexpr -> expr unit -> expr unit -> expr unit*)
let mk_if_e_ annots1 pe e1 e2 =
   (Expr( annots1, (Eif( pe, e1, e2))))

(*val mk_if_e: pexpr -> expr unit -> expr unit -> expr unit*)
let mk_if_e pe e1 e2 =
   (Expr( [], (Eif( pe, e1, e2))))

(*val mk_let_e: pattern -> pexpr -> expr unit -> expr unit*)
let mk_let_e pat pe e =
   (Expr( [], (Elet( pat, pe, e))))

(*val mk_ccall_e_: list annot -> pexpr -> pexpr -> list pexpr -> expr unit*)
let mk_ccall_e_ annots1 cty pe pes =
   (Expr( annots1, (Eccall( (), cty, pe, pes))))

(*val mk_memop_e: Mem_common.memop -> list pexpr -> expr unit*)
let mk_memop_e mop pes =
   (Expr( [], (Ememop( mop, pes))))

(*val mk_wait_e: forall 'a. Mem_common.thread_id -> expr 'a*)
let mk_wait_e tid1 =
   (Expr( [], (Ewait tid1)))

(*val add_loc: Loc.t -> expr unit -> expr unit*)
let add_loc loc1 (Expr( annot1, expr_)) =
   (let pred = ((function
    | Aloc _ -> true
    | _ -> false
  )) in
  Expr( ((match Lem_list.list_delete_first pred annot1 with
    | None ->
        (Aloc loc1) :: annot1
    | Some xs' ->
        (Aloc loc1) :: xs'
  )), expr_))

(*val add_stmt: expr unit -> expr unit*)
let add_stmt (Expr( annot1, expr_)) =
   (Expr( (Astmt :: annot1), expr_))

(*val add_expr: expr unit -> expr unit*)
let add_expr (Expr( annot1, expr_)) =
   (Expr( (Aexpr :: annot1), expr_))

(*val add_std: string -> expr unit -> expr unit*)
let add_std str (Expr( annot1, expr_)) =
   (Expr( (Astd str :: annot1), expr_))

(*val add_stds: list string -> expr unit -> expr unit*)
let add_stds strs (Expr( annot1, expr_)) =
   (Expr( ( List.rev_append (List.rev (Lem_list.map (fun z -> Astd z) strs)) annot1), expr_))

(*val add_attrs: Annot.attributes -> expr unit -> expr unit*)
let add_attrs attrs1 ((Expr( annot1, expr_) as expr1)) =
   ((match attrs1 with
    | Attrs [] ->
        expr1
    | _ ->
        Expr( (Aattrs attrs1 :: annot1), expr_)
  ))

(*val add_annot: Annot.annot -> expr unit -> expr unit*)
let add_annot annot1 (Expr( annots1, expr_)) =
   (Expr( (annot1 :: annots1), expr_))

(*val add_annots: list Annot.annot -> expr unit -> expr unit*)
let add_annots annots1 (Expr( annots2, expr_)) =
   (Expr( ( List.rev_append (List.rev annots1) annots2), expr_))

type 'a collect_saves_state = {
  tmp_acc: (Symbol.sym, ( (Symbol.sym * core_base_type)list * 'a Core.expr))    Pmap.map; (*Core.labeled_continuations 'a; *)
  closed_acc: (Symbol.sym, ( (Symbol.sym * core_base_type)list * 'a Core.expr)) Pmap.map; (*Core.labeled_continuations 'a; *)
}

let empty_saves =  ({ tmp_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)); closed_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)) })

let union_saves st1 st2 =
   ({ tmp_acc= (Pmap.union st1.tmp_acc st2.tmp_acc);
     closed_acc= (Pmap.union st1.closed_acc st2.closed_acc) })

(* NOTE: assumes the expression is well formed/typed *)
(*val     collect_saves_aux: forall 'a. collect_saves_state 'a -> expr 'a -> collect_saves_state 'a*)
let rec collect_saves_aux st (Expr( annots1, expr_)) =
   ((match expr_ with
    | Epure _ ->
        st
    | Ememop( _, _) ->
        st
    | Eaction _ ->
        st
    | Ecase( _, pat_es) ->
        List.fold_left (fun acc (_, e) ->
          collect_saves_aux acc e
        ) st pat_es
    | Elet( _, _, e) ->
        collect_saves_aux st e
    | Eif( _, e1, e2) ->
        collect_saves_aux (collect_saves_aux st e1) e2
    | Eccall( _, _, _, _) ->
        st
    | Eproc( _, _, _) ->
        st
    | Eunseq es ->
        List.fold_left collect_saves_aux st es
    | Ewseq( pat, e1, e2) ->
        let st1 = (collect_saves_aux empty_saves e1) in
        let st2 = (collect_saves_aux empty_saves e2) in
        union_saves st begin
          union_saves
            { st1 with
              tmp_acc= (Pmap.map (fun (syms, e) -> (syms, Expr( annots1, (Ewseq( pat, e, e2))))) st1.tmp_acc)
            }
            st2
        end
    | Esseq( pat, e1, e2) ->
        let st1 = (collect_saves_aux empty_saves e1) in
        let st2 = (collect_saves_aux empty_saves e2) in
        union_saves st begin
          union_saves
            { st1 with
              tmp_acc= (Pmap.map (fun (syms, e) -> (syms, Expr( annots1, (Esseq( pat, e, e2))))) st1.tmp_acc)
            }
            st2
        end
    | Ebound _ ->
        (* typing forbids "saves" inside a "bound()" *)
        st
    | End _ ->
        (* typing forbids "saves" inside a "nd()" *)
        st
    | Esave( (sym1, _), params, e) ->
        collect_saves_aux
          { st with tmp_acc= (Pmap.add sym1 (Lem_list.map (fun (x, ((y, _), _)) -> (x, y)) params, e) st.tmp_acc) }
          e
    | Erun( _, _, _) ->
        st
    | Epar es ->
        let acc = (List.fold_left collect_saves_aux
          empty_saves es) in
        { st with closed_acc=
          (Pmap.union (Pmap.union acc.tmp_acc acc.closed_acc)
                      st.closed_acc) }
    | Ewait _ ->
        st
    | Eannot( _, _) ->
        (* typing forbids "saves" inside a "annot()" *)
        st
    | Eexcluded( _, _) ->
        (* typing forbids "saves" inside a "excluded()" *)
        st
  ))

(*val collect_saves: forall 'a. expr 'a -> map Symbol.sym (list (Symbol.sym * core_base_type) * expr 'a)*) (*Core.labeled_continuations 'a *)
let collect_saves expr1 =
   (let st = (collect_saves_aux { tmp_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)); closed_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)) } expr1) in
  Pmap.union st.tmp_acc st.closed_acc)






(* The same again, now collecting more information about the
   esave. The above could be defined in terms of the below, but I
   didn't want to mess that up, so leaving for now. *)

type 'a m_labeled_continuation = 
  (core_base_type * (Symbol.sym * ((core_base_type *  (Ctype.ctype * pass_by_value_or_pointer)option) * pexpr)) list * ( 'a expr) * Annot.annot list)

type 'a m_labeled_continuations = (Symbol.sym, ( 'a m_labeled_continuation)) 
  Pmap.map

type 'a m_collect_saves_state = {
  m_tmp_acc: 'a    m_labeled_continuations;
  m_closed_acc: 'a m_labeled_continuations;
}

let m_empty_saves =  ({ m_tmp_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)); m_closed_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)) })

let m_union_saves st1 st2 =
   ({ m_tmp_acc= (Pmap.union st1.m_tmp_acc st2.m_tmp_acc);
     m_closed_acc= (Pmap.union st1.m_closed_acc st2.m_closed_acc) })

(* NOTE: assumes the expression is well formed/typed *)
(*val     m_collect_saves_aux: forall 'a. m_collect_saves_state 'a -> expr 'a -> m_collect_saves_state 'a*)
let rec m_collect_saves_aux st (Expr( annots1, expr_)) =
   ((match expr_ with
    | Epure _ ->
        st
    | Ememop( _, _) ->
        st
    | Eaction _ ->
        st
    | Ecase( _, pat_es) ->
        List.fold_left (fun acc (_, e) ->
          m_collect_saves_aux acc e
        ) st pat_es
    | Elet( _, _, e) ->
        m_collect_saves_aux st e
    | Eif( _, e1, e2) ->
        m_collect_saves_aux (m_collect_saves_aux st e1) e2
    | Eccall( _, _, _, _) ->
        st
    | Eproc( _, _, _) ->
        st
    | Eunseq es ->
        List.fold_left m_collect_saves_aux st es
    | Ewseq( pat, e1, e2) ->
        let st1 = (m_collect_saves_aux m_empty_saves e1) in
        let st2 = (m_collect_saves_aux m_empty_saves e2) in
        m_union_saves st begin
          m_union_saves
            { st1 with
              m_tmp_acc= (Pmap.map (fun (cbt,args,body,annots') -> 
                             (cbt, args, Expr( annots1, (Ewseq( pat, body, e2))), annots') )
                               st1.m_tmp_acc)
            }
            st2
        end
    | Esseq( pat, e1, e2) ->
        let st1 = (m_collect_saves_aux m_empty_saves e1) in
        let st2 = (m_collect_saves_aux m_empty_saves e2) in
        m_union_saves st begin
          m_union_saves
            { st1 with
              m_tmp_acc= (Pmap.map (fun (cbt,args,body,annots') -> 
                             (cbt, args, Expr( annots1, (Esseq( pat, body, e2))), annots') )
                               st1.m_tmp_acc)
            }
            st2
        end
    | Ebound _ ->
        (* typing forbids "saves" inside a "bound()" *)
        st
    | End _ ->
        (* typing forbids "saves" inside a "nd()" *)
        st
    | Esave( (sym1, ty1), params, e) ->
	   let oloc = (Annot.get_loc annots1) in
	   let () = ((match oloc with 
	     | Some _ -> () 
		 | _ -> Cerb_debug.print_debug 0 [] (fun () -> "label " ^ (Symbol.show_symbol sym1 ^ "missing label location"))
		)) in
        m_collect_saves_aux
          { st with m_tmp_acc= (Pmap.add sym1 (ty1,params,e,annots1) st.m_tmp_acc) }
          e
    | Erun( _, _, _) ->
        st
    | Epar es ->
        let acc = (List.fold_left m_collect_saves_aux
          m_empty_saves es) in
        { st with m_closed_acc=
          (Pmap.union (Pmap.union acc.m_tmp_acc acc.m_closed_acc)
                      st.m_closed_acc) }
    | Ewait _ ->
        st
    | Eannot( _, _) ->
        st
    | Eexcluded( _, _) ->
        st
  ))

(*val m_collect_saves: forall 'a. expr 'a -> m_labeled_continuations 'a*)
let m_collect_saves expr1 =
   (let st = (m_collect_saves_aux { m_tmp_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)); m_closed_acc= (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)) } expr1) in
  Pmap.union st.m_tmp_acc st.m_closed_acc)





(*import Map_extra*)

(*val collect_labeled_continuations_NEW: forall 'a. file 'a -> map Symbol.sym (map Symbol.sym (list (Symbol.sym * core_base_type) * expr 'a) (*Core.labeled_continuations 'a *))*)
let collect_labeled_continuations_NEW file1 =
   (
(*  let xs =  *)Pmap.fold (fun fun_sym decl acc ->
    (match decl with
      | Fun( _, _, _) ->
          acc
      | ProcDecl( _, _, _) ->
          acc
      | BuiltinDecl( _, _, _) ->
          acc
      | Proc( _, _, _, _, e) ->
          Pmap.add fun_sym (collect_saves e) acc
    )
  ) (Pmap.union file1.stdlib file1.funs) (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)))
(*
in
  let _ = Map.mapi (fun sym labs ->
    Debug.print_debug 2 [] (fun () ->
      "PROC " ^ show sym ^ " ==>\n" ^
      List.foldl (fun acc (sym, (_, e)) -> show sym ^ " ==> " ^ Pp.stringFromCore_expr e) "" (Map_extra.toList labs) 
    )
  ) xs in
  xs
*)


(*val     update_env: pattern -> value -> list (map Symbol.sym value) -> list (map Symbol.sym value)*)
let rec update_env_aux dict_Map_MapKeyType_a (Pattern( _, pat)) cval env1 =
   (
  (* TODO (maybe), Carray, Civmax, Civmin, Civsizeof, Civalignof *)(match (pat, cval) with
    | (CaseBase (None, _), _) ->
        (* e[_ \ v] = e *)
        env1
    | (CaseBase (Some sym1, _), _) ->
        (* e[sym \ v] *)
        Pmap.add sym1 cval env1
    | (CaseCtor( (Cnil _), []), Vlist( _, [])) ->
        (* empty list (value) *)
        env1
    | (CaseCtor( Ccons, [pat1; pat2]), Vlist( bTy_elem, (cval1::cvals))) ->
        (* populated list (value) *) update_env_aux 
  dict_Map_MapKeyType_a pat1 cval1 (update_env_aux 
  dict_Map_MapKeyType_a pat2 (Vlist( bTy_elem, cvals)) env1)
    | (CaseCtor( Ctuple, pats'), Vtuple cvals) ->
        List.fold_right (fun (pat', cval') acc ->
          update_env_aux 
  dict_Map_MapKeyType_a pat' cval' acc
        ) (Lem_list.list_combine pats' cvals) env1
    | (CaseCtor( Cspecified, [pat']), Vloaded (LVspecified oval)) ->
        update_env_aux 
  dict_Map_MapKeyType_a pat' (Vobject oval) env1
    | (CaseCtor( Cunspecified, [pat']), Vloaded (LVunspecified ty1)) ->
        update_env_aux 
  dict_Map_MapKeyType_a pat' (Vctype ty1) env1
    | (CaseCtor( ctor1, pats), _) ->
        let str_ctor = ((match ctor1 with
          | Cnil _ ->
              "nil"
          | Ccons ->
              "cons"
          | Ctuple ->
              "tuple"
          | Carray ->
              "array"
          | Civmax ->
              "ivmax"
          | Civmin ->
              "ivmin"
          | Civsizeof ->
              "ivsizeof"
          | Civalignof ->
              "ivalignof"
          | CivCOMPL ->
              "ivCOMPL"
          | CivAND ->
              "ivAND"
          | CivOR ->
              "ivOR"
          | CivXOR ->
              "ivXOR"
          | Cspecified ->
              "specified"
          | Cunspecified ->
              "unspecified"
          | Cfvfromint ->
              "fvfromint"
          | Civfromfloat ->
              "ivfromfloat"
          | CivNULLcap is_signed ->
              "ivNULLcap(" ^ (if is_signed then "signed" else "unsigned" ^ ")")  
        )) in
        Cerb_debug.error ("WIP: Core_aux.update_env_aux ==> ctor= " ^ (str_ctor ^ (", |pats|= "
               ^ ((string_of_int (List.length pats)) ^ (" -- " ^ String_core.string_of_value cval)))))
  ))

let update_env pat cval =  ((function
  | [] ->
      Cerb_debug.error "Core_aux.update_env: found empty env"
  | env1::xs ->
      update_env_aux (instance_Map_MapKeyType_var_dict
   Symbol.instance_Basic_classes_SetType_Symbol_sym_dict) pat cval  env1 :: xs
))


let rec lookup_env sym1 =  ((function
  | [] ->
      None
  | env1 :: xs ->
      (match Pmap.lookup sym1 env1 with
        | None ->
            lookup_env sym1 xs
        | Some ret ->
            Some ret
      )
))

