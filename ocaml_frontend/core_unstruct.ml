(*Generated by Lem from frontend/model/core_unstruct.lem.*)
open Lem_pervasives
open Utils
open Core
open Ctype
open Ctype_aux
(*import Symbol State Core_aux Ctype*)

(*import Core_typing Core_typing_effect Core_typing_aux*)


module Caux = Lem_core_aux



let insupported str:'a=
   (Cerb_debug.error ("Core_unstruct: unsupported ==> " ^ str))


(*val extract_ctype_pe: typed_pexpr -> maybe (either ctype (Symbol.sym * list (Symbol.identifier * (Annot.attributes * maybe alignment * qualifiers * ctype))))*)
let extract_ctype_pe (Pexpr( _, _, pexpr_)):(((ctype),(Symbol.sym*(Symbol.identifier*(Annot.attributes*(alignment)option*qualifiers*ctype))list))Either.either)option=
   ((match pexpr_ with
    | PEval (Vctype ((Ctype( _, ty1) as cty))) ->
        Some (match ty1 with
          | Atomic (Ctype( _, (Struct _))) ->
              insupported "atomic struct"
          | Atomic (Ctype( _, (Union _))) ->
              insupported "atomic union"
          | Struct tag_sym ->
              (* TODO(check) ignoring flexible array members *)
              Either.Right (tag_sym, fst (get_structDef tag_sym))
          | Union tag_sym ->
              (*let xs = get_unionDef tag_sym in*)
              insupported "(non atomic) union"
          | _ ->
              Either.Left cty
        )
    | _ ->
        None
  ))

(*val extract_alignement_type: typed_pexpr -> maybe ctype*)
let extract_alignement_type (Pexpr( _, _, pexpr_)):(ctype)option=
   ((match pexpr_ with
    | PEctor( Civalignof, [Pexpr( _, _, (PEval (Vctype ty1)))]) ->
        Some ty1
    | _ ->
        None
  ))


(*val type_pexpr: pexpr -> typed_pexpr*)
let type_pexpr pexpr1 =
   (let tagDefs1 = (Tags.tagDefs ()) in
  let m =
    (Exception.except_bind
      (Core_typing.infer_pexpr tagDefs1 Core_typing_aux.empty_env pexpr1)
      Core_typing_aux.export_pexpr) in
  (match Core_typing_effect.runM m with
    | Exception.Result pexpr' ->
        pexpr'
    | _ ->
        Cerb_debug.error "Core_unstruct.type_pexpr: failed to type"
  ))


(*val typeof_pexpr: typed_pexpr -> core_base_type*)
let typeof_pexpr (Pexpr( _, bTy, _)):core_base_type=
   bTy


(*val is_pointer_type: core_base_type -> bool*)
let is_pointer_type:core_base_type ->bool=  ((function
  | BTy_object OTy_pointer ->
      true
  | _ ->
      false
))


type explode_env = (Symbol.sym, ( (Symbol.identifier * Symbol.sym)list))
  Pmap.map



(* If the given expression is a pointer to a struct, explode it to pointers to the members *)
(*val explode_ptr_pexpr: explode_env -> typed_pexpr -> maybe (list (Symbol.identifier * typed_pexpr))*)
let explode_ptr_pexpr env1 (Pexpr( annot1, bTy, pexpr_)) =
   ((match pexpr_ with
    | PEsym ptr_sym ->
        (match Pmap.lookup ptr_sym env1 with
          | Some xs ->
              Some begin
                Lem_list.map (fun (ident, sym1) ->
                  (ident, Pexpr( annot1, bTy, (PEsym sym1)))
                ) xs
              end
          | None ->
              None
        )
    
    | _ ->
        None (* TODO: check *)
  ))


(*val explode_paction: explode_env -> typed_paction unit -> list (typed_expr_ unit) *)
let explode_paction env1 (Paction( pol, (Action( loc1, a, act_)))) =
   (let wrap z=
     (Eaction (Paction( pol, (Action( loc1, a, z))))) in
  (match act_ with
    | Create( al_pe1, ty_pe2, pref) ->
        (match (extract_alignement_type al_pe1, extract_ctype_pe ty_pe2) with
          | (_, Some (Either.Left _)) ->
              (* this is not allocating a struct, so no need to explode *)
              None
          | (Some (Ctype( _, al_ty)), Some (Either.Right (tag_sym, xs))) ->
              if unsafe_structural_inequality al_ty (Struct tag_sym) then
                insupported "create with non-trivial alignement constraint"
              else
                Some begin
                  Lem_list.map (fun (ident, (_, align_opt, _, ty1)) ->
                    let ty_pe = (Core_aux.mk_ctype_pe ty1) in
                    let align_pe =
                      ((match align_opt with
                        | Some (AlignInteger n) ->
                            Core_aux.mk_integer_pe n
                        | Some (AlignType align_ty) ->
                            Core_aux.mk_alignof_pe (Core_aux.mk_ctype_pe align_ty)
                        | None ->
                            Core_aux.mk_alignof_pe ty_pe
                      )) in
                    (ident, wrap (Create( (type_pexpr align_pe), (type_pexpr ty_pe), pref)))
                  ) xs
                end
          | (_, _) ->
              None (* TODO: Kayvan please check *)
        )
(*
    | CreateReadOnly pe1 pe2 pe3 pref ->
        error "WIP"
    | Alloc e1 e2 pref ->
        error "WIP"
*)
    | Kill( kind1, ptr_pe) ->
        (match explode_ptr_pexpr env1 ptr_pe with
          | None ->
              None
          | Some xs ->
              Some begin
                Lem_list.map (fun (ident, pe') ->
                  (ident, wrap (Kill( kind1, pe')))
                ) xs
              end
        )
(*
    | Store is_locking pe1 pe2 pe3 mo ->
        error "WIP"
    | Load pe1 pe2 mo ->
        match extract_ctype_pe pe1 with
          | Nothing ->
              [Eaction pact]
        end
    | RMW pe1 pe2 pe3 pe4 mo1 mo2 ->
        error "WIP"
    | Fence mo ->
        error "WIP"
    | CompareExchangeStrong pe1 pe2 pe3 pe4 mo1 mo2 ->
        error "WIP"
    | LinuxFence mo ->
        error "WIP"
    | LinuxLoad pe1 pe2 mo ->
        error "WIP"
    | LinuxStore pe1 pe2 pe3 mo ->
        error "WIP"
    | LinuxRMW pe1 pe2 pe3 mo ->
        error "WIP"
*)
    | _ ->
        None
  ))
  

(*
(*val     foo: forall 'a. typed_expr 'a ->  *)
let rec fetch_types (Expr annot expr_) =
  match expr_ with
(*
    | Epure pe ->
        [typeof_pexpr pe]
    | Ememop of Mem_common.memop * list (generic_pexpr 'bty 'sym) (* pointer op involving memory *)
    | Eaction of (generic_paction 'a 'bty 'sym) (* memory action *)
    | Ecase of (generic_pexpr 'bty 'sym) * list ((generic_pattern 'bty 'sym) * (generic_expr 'a 'bty 'sym)) (* pattern matching *)
    | Elet of (generic_pattern 'bty 'sym) * (generic_pexpr 'bty 'sym) * (generic_expr 'a 'bty 'sym) (* Core let *)
    | Eif of (generic_pexpr 'bty 'sym) * (generic_expr 'a 'bty 'sym) * (generic_expr 'a 'bty 'sym) (* Core if *)
    | Eskip (* skip *)
    | Eccall of 'a * (generic_pexpr 'bty 'sym) * (generic_pexpr 'bty 'sym) * list (generic_pexpr 'bty 'sym) (* Core cfunction call *)
    | Eproc of 'a * generic_name 'sym * list (generic_pexpr 'bty 'sym) (* Core procedure call *)
    | Eunseq of list (generic_expr 'a 'bty 'sym) (* unsequenced expressions *)
*)
(*
    | Ewseq pat e1 e2 ->
*)

    | Esseq pat e1 e2 ->
        match e1 with
          | Expr _ (Eaction pact) ->
              error "WIP"
        end

(*
    | Ebound of (generic_expr 'a 'bty 'sym) (* $\ldots$and boundary *)
    | End of list (generic_expr 'a 'bty 'sym) (* nondeterministic sequencing *)
          (* the pexpr associated to the symbols are their value when the control flows throught the Esave (i.e. when
             doesn't come from a Erun) *)
    | Esave of ('sym * core_base_type) * list ('sym * (core_base_type * generic_pexpr 'bty 'sym)) * generic_expr 'a 'bty 'sym
    | Erun of 'a * 'sym * list (generic_pexpr 'bty 'sym)
    | Epar of list (generic_expr 'a 'bty 'sym) (* cppmem thread creation *)
    | Ewait of thread_id (* wait for thread termination *)
*)
  end
  *)


(*val mk_ptr_tuple_pe: list typed_pexpr -> typed_pexpr*)
let mk_ptr_tuple_pe pes =
   (let n = (List.length pes) in
  let bTy = (BTy_tuple (replicate_list (BTy_object OTy_pointer) n)) in
  Pexpr( [], bTy, (PEctor( Ctuple, pes))))

(*val mk_ptr_sym_pe: Symbol.sym -> typed_pexpr*)
let mk_ptr_sym_pe sym1 =
   (Pexpr( [], (BTy_object OTy_pointer), (PEsym sym1)))


(*val     explode_expr: explode_env -> typed_expr unit -> typed_expr unit*)
let rec explode_expr env1 ((Expr( annot1, expr_) as expr1)) =
   (let self e=  (explode_expr env1 e) in
  let wrap z=  (Expr( annot1, z)) in
  (match expr_ with
    | Eaction (Paction( pol, (Action( loc1, a, (Kill( kind1, ptr_pe)))))) ->
        (match explode_ptr_pexpr env1 ptr_pe with
          | None ->
              expr1
          | Some xs ->
              begin
                List.fold_left (fun acc (_, pe') ->
                  Expr( [], (Esseq( (Pattern( [], (CaseBase (None, BTy_unit)))),
                                 (Expr( [], (Eaction (Paction( pol, (Action( loc1, a, (Kill( kind1, pe'))))))))),
                                 acc)))
                ) (Expr( [], (Epure (Pexpr( [], BTy_unit, (PEval Vunit)))))) xs
              end
        )
    
    | Esseq( ((Pattern( pat_annot, (CaseBase (Some sym1, BTy_object OTy_pointer))) as pat)), ((Expr( annot1, (Eaction pact)) as e1)), e2) ->
        (match explode_paction env1 pact with
          | None ->
              wrap (Esseq( pat, e1, (explode_expr env1 e2)))
          | Some xs ->
              let (syms, rev_xs) =
                (List.fold_left (fun (acc1, acc2) (ident, e_) ->
                  let sym' = (Symbol.fresh ()) in
                  (((ident, sym') :: acc1), ((sym', e_) :: acc2))
                ) ([], []) xs) in
              let env' : explode_env = (Pmap.add sym1 syms env1) in
              List.fold_left (fun acc (sym', e_) ->
                Expr( [], (Esseq( (Pattern( [], (CaseBase (Some sym', BTy_object OTy_pointer)))), (Expr( annot1, e_)), acc)))
              ) (explode_expr env' e2) rev_xs
        )
    
    | Esseq( ((Pattern( pat_annot, (CaseBase (Some pat_sym, BTy_object OTy_pointer))) as pat)),
            ((Expr( annot1, (Epure (Pexpr( pe_annot, pe_bTy, (PEsym sym1))))) as e1)), e2) ->
        (match Pmap.lookup sym1 env1 with
          | None ->
              wrap (Esseq( pat, e1, (explode_expr env1 e2)))
          | Some xs ->
              let e1' = (Expr( annot1, (Epure (mk_ptr_tuple_pe (Lem_list.map (fun (_, z) -> mk_ptr_sym_pe z) xs))))) in
              
              let ys =
                (Lem_list.map (fun (ident, _) -> (ident, Symbol.fresh ())) xs) in
              
              let pat' =
                (Pattern( pat_annot, (CaseCtor( Ctuple, (Lem_list.map (fun (_, z) ->
                  Pattern( [], (CaseBase (Some z, BTy_object OTy_pointer)))
                ) ys))))) in
              
              wrap (Esseq( pat', e1', (explode_expr (Pmap.add pat_sym ys env1) e2)))
        )
    
    | Epure (Pexpr( _, _, (PEmember_shift( (Pexpr( _, _, (PEsym ptr_sym))), _, ident)))) ->
        (match Lem.option_bind (Pmap.lookup ptr_sym env1) ((lookupBy Symbol.idEqual ident)) with
          | None ->
              let () = (Cerb_debug.print_debug 0 [] (fun () -> stringFromMaybe (fun xs->stringFromList (stringFromPair (fun ident->let Symbol.Identifier( _, str) = ident in
    str) Symbol.show_symbol) xs) (Pmap.lookup ptr_sym env1))) in
              expr1 (* error "Core_unstruct.explode_expr: Epure PEmember_shift -- lookup failed" *)
          | Some sym1 ->
              wrap (Epure (mk_ptr_sym_pe sym1))
        )
    | Epure pe ->
        if is_pointer_type (typeof_pexpr pe) then
          (match explode_ptr_pexpr env1 pe with
            | None ->
                expr1
            | Some xs ->
                wrap (Epure (mk_ptr_tuple_pe (Lem_list.map snd xs)))
          )
        else
          expr1
    | Ememop( _, _) ->
        expr1
    | Eaction _ ->
        expr1
    | Ecase( pe, xs) ->
        wrap (Ecase( pe, (Lem_list.map (fun (pat, e) -> (pat, self e)) xs)))
    | Elet( pat, pe, e) ->
        wrap (Elet( pat, pe, (self e)))
    | Eif( pe, e1, e2) ->
        wrap (Eif( pe, (self e1), (self e2)))
    | Eccall( _, _, _, _) ->
        expr1
    | Eproc( _, _, _) ->
        expr1
    | Eunseq es ->
        wrap (Eunseq (Lem_list.map self es))
    | Ewseq( pat, e1, e2) ->
        wrap (Ewseq( pat, (self e1), (self e2)))
    | Esseq( pat, e1, e2) ->
        wrap (Esseq( pat, (self e1), (self e2)))
    | Ebound e ->
        wrap (Ebound (self e))
    | End es ->
        wrap (End (Lem_list.map self es))
    | Esave( _, _, _) ->
        expr1
    | Erun( _, _, _) ->
        expr1
    | Epar es ->
        wrap (Epar (Lem_list.map self es))
    | Ewait _ ->
        expr1
    | Eannot( xs, e) ->
        wrap (Eannot( xs, (self e)))
    | Eexcluded( _, _) ->
        expr1
  ))



(*val explode_fun_map: typed_fun_map unit -> typed_fun_map unit*)
let explode_fun_map funs1 =
   (Pmap.map ((function
    | Proc( loc1, mrk, bTy, xs, e) ->
        Proc( loc1, mrk, bTy, xs, (explode_expr (Pmap.empty (fun sym1 sym2->ordCompare 
  Symbol.instance_Basic_classes_Eq_Symbol_sym_dict Symbol.instance_Basic_classes_Ord_Symbol_sym_dict sym1 sym2)) e))
    | z ->
        z
  )) funs1)


(*val explode_file: typed_file unit -> typed_file unit*)
let explode_file file1 =
   ({ file1 with
       funs= (explode_fun_map file1.funs) })
