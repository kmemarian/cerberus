open import List
import Exception

(* HACK: most of the inlines are only added to prevent Lem's renaming *)


type stExceptM 'a 'st 'msg =
  'st -> Exception.exceptM ('a * 'st) 'msg

val stExpect_return: forall 'a 's 'msg. 'a -> stExceptM 'a 's 'msg
val stExpect_bind: forall 'a 'b 's 'msg. stExceptM 'a 's 'msg -> ('a -> stExceptM 'b 's 'msg) -> stExceptM 'b 's 'msg

let stExpect_return a =
  fun s -> Exception.return (a, s)

let stExpect_bind m f = fun s ->
  Exception.bind (m s) (fun (a, s') -> (f a) s')


(* Reinventing the wheel *)
val fmap: forall 'a 'b 's 'msg. ('a -> 'b) -> stExceptM 'a 's 'msg -> stExceptM 'b 's 'msg
let inline fmap f m = stExpect_bind m (fun z -> stExpect_return (f z))

val app: forall 'a 'b 's 'msg. stExceptM ('a -> 'b) 's 'msg -> stExceptM 'a 's 'msg -> stExceptM 'b 's 'msg
let inline app  mf m = stExpect_bind mf (fun f -> fmap f m)


val stExpect_mapM: forall 'a 'b 's 'msg.
  ('a -> stExceptM 'b 's 'msg) ->
  list 'a ->
  stExceptM (list 'b) 's 'msg
let stExpect_mapM f xs =
  foldr
    (fun m m' ->
      stExpect_bind m (fun x ->
      stExpect_bind m' (fun xs ->
      stExpect_return (x::xs)
    ))) (stExpect_return [])
    (List.map f xs)

val mapM_: forall 'a 'b 's 'msg.
  ('a -> stExceptM 'b 's 'msg) ->
  list 'a ->
  stExceptM unit 's 'msg
let inline mapM_ f xs =
  foldr
    (fun m f -> stExpect_bind m (fun _ -> f))
    (stExpect_return ())
    (List.map f xs)



val     stExcept_foldlM: forall 'a 'b 's 'msg. ('a -> 'b -> stExceptM 'a 's 'msg) -> 'a -> list 'b -> stExceptM 'a 's 'msg
let rec stExcept_foldlM f a = function
  | []    -> stExpect_return a
  | b::bs -> stExpect_bind (f a b) (fun a' -> stExcept_foldlM f a' bs)
end

val     foldrM: forall 'a 'b 's 'msg. ('a -> 'b -> stExceptM 'b 's 'msg) -> 'b -> list 'a -> stExceptM 'b 's 'msg
let rec foldrM f a = function
  | [] -> stExpect_return a
  | x::xs -> stExpect_bind (foldrM f a xs) (f x)
end

let inline iter f l = stExcept_foldlM (fun () a -> f a) () l


(* Exception stuff *)
let inline fail msg = fun _ -> Exception.fail msg


(* hijack the error message of a failing computation *)
val tryWith: forall 'a 's 'msg. 'msg -> stExceptM 'a 's 'msg -> stExceptM 'a 's 'msg
let tryWith msg m =
  fun st ->
    Exception.bind_exception (m st) (fun _ -> Exception.fail msg)

(* The state actions *)
val read:   forall 'a 's 'msg. ('s -> 'a) -> stExceptM 'a 's 'msg
val update: forall 's 'msg. ('s -> 's) -> stExceptM unit 's 'msg
val modify: forall 'a 's 'msg. ('s -> 'a * 's) -> stExceptM 'a 's 'msg
val eval:   forall 'a 'b 's 'msg. stExceptM 'a 's 'msg -> 's -> Exception.exceptM 'a 'msg
let state_except_read   f = fun s -> Exception.return (f s, s)
let state_except_update f = fun s -> Exception.return ((), f s)
let state_except_modify f = fun s -> Exception.return (f s)
let state_except_eval   m = fun s -> Exception.fmap (fun (x, _) -> x) (m s)
let inline read = state_except_read
let inline update = state_except_update
let inline modify = state_except_modify
let inline eval = state_except_eval

val get: forall 'st 'msg. stExceptM 'st 'st 'msg
val put: forall 'st 'msg. 'st -> stExceptM unit 'st 'msg
let state_except_get = fun st -> Exception.return (st, st)
let state_except_put st = fun _ -> Exception.return ((), st)
let inline get = state_except_get
let inline put = state_except_put


val liftException: forall 'a 'state 'msg. Exception.exceptM 'a 'msg -> stExceptM 'a 'state 'msg
let liftException m =
  fun st -> Exception.fmap (fun z -> (z, st)) m 


(* HACK: this is a hack to prevent Lem from generating OCaml code with random renamings *)
let inline foldlM = stExcept_foldlM

let inline return = stExpect_return
let inline bind = stExpect_bind
let inline mapM = stExpect_mapM
