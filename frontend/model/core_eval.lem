open import Pervasives

open import Utils
open import Core
open import Core_run_aux
import Errors
import Mem
import AilTypesAux
import Loc Symbol Exception_undefined Pp

import Ctype Ctype_aux Core_aux
module Caux = Core_aux

module EU  = Exception_undefined

import Exception

import Nondeterminism
module ND = Nondeterminism

let illformed_program str =
  EU.fail (Errors.Illformed_program str)


(* -- see ยง5.1.2 from ISO/IEC 10967-1:1994(E)
fun wrapI(ty: ctype, n: integer) : integer :=
  let dlt: integer = Ivmax(ty) - Ivmin(ty) + 1 in
  let r: integer = n rem_f dlt in
  if r <= Ivmax(ty) then
    r
  else
    r - dlt *)
let mk_wrapI ity ival =
  match ( Mem.eval_integer_value (Mem.min_ival ity)
        , Mem.eval_integer_value (Mem.max_ival ity) ) with
    | (Just min, Just max) ->
        let dlt = max - min + 1 in
        match Mem.eval_integer_value (Mem.op_ival Mem_common.IntRem_f ival (Mem.integer_ival dlt)) with
          | Nothing ->
              error "Core_eval.mk_wrapI"
          | Just r ->
              Mem.integer_ival begin
                if r <= max then
                  r
                else
                  r - dlt
              end
        end
    | _ ->
        error "Core_eval.mk_wrapI"
  end

(*
  if ty = '_Bool' then
    if n = 0 then 0 else 1
  else
    if is_representable_integer(n, ty) then
      n
    else
      if is_unsigned(ty) then
        wrapI(ty, n)
      else
        <Integer.conv_nonrepresentable_signed_integer>(ty, n)
*)
let mk_conv_int ity ival =
  match Mem.eval_integer_value ival with
    | Nothing ->
        error "Core_eval.mk_conv_int"
    | Just n ->
        if Ctype.integerTypeEqual ity Ctype.Bool then
          Mem.integer_ival (if n = 0 then 0 else 1)
        else
          match ( Mem.eval_integer_value (Mem.min_ival ity)
                , Mem.eval_integer_value (Mem.max_ival ity) ) with
            | (Just min, Just max) ->
                let n_ival = Mem.integer_ival n in
                if min <= n && n <= max then
                  n_ival
                else
                  (* TODO need to have the impl-def <Integer.conv_nonrepresentable_signed_integer>(ty, n) (if ity is unsigned) *)
                  mk_wrapI ity n_ival
            | _ ->
                error "Core_eval.mk_conv_int"
          end
    end

let mk_iop = function
  | IOpAdd -> fun x y -> Mem.op_ival Mem_common.IntAdd x y
  | IOpSub -> fun x y -> Mem.op_ival Mem_common.IntSub x y
  | IOpMul -> fun x y -> Mem.op_ival Mem_common.IntMul x y
  | IOpDiv -> fun x y -> Mem.op_ival Mem_common.IntDiv x y
  | IOpRem_t -> fun x y -> Mem.op_ival Mem_common.IntRem_t x y
  | IOpShl -> fun x y -> Mem.op_ival Mem_common.IntMul x (Mem.op_ival Mem_common.IntExp (Mem.integer_ival 2) y)
  | IOpShr -> fun x y -> Mem.op_ival Mem_common.IntDiv x (Mem.op_ival Mem_common.IntExp (Mem.integer_ival 2) y)
end

let mk_wrapI_op ity iop ival1 ival2 =
  (* let ival1 = mk_conv_int ity ival1 in
  let ival2 = mk_conv_int ity ival2 in *)
  mk_wrapI ity (mk_iop iop ival1 ival2)


let mk_call_catch_exceptional_condition ity iop ival1 ival2 =
  let ival = mk_iop iop ival1 ival2 in
  match ( Mem.eval_integer_value (Mem.min_ival ity)
        , Mem.eval_integer_value (Mem.max_ival ity)
        , Mem.eval_integer_value ival ) with
    | (Just min, Just max, Just n) ->
        if min <= n && n <= max then
          Just ival
        else
          Nothing
    | _ ->
        error "Core_eval.mk_call_catch_exceptional_condition"
  end




(* takes the symbolic names of a function, some pure expressions and produce
   the function body where the arguments have been substituted *)
val call_function: Core.file core_run_annotation -> name -> list Core.value ->
                   Exception.exceptM Core.pexpr Errors.core_run_cause
let call_function file f_nm arg_cvals =
  let () = Debug.print_debug 5 [] (fun () ->
    "CALL_FUNCTION: " ^ Pp.stringFromCore_pexpr (Pexpr [] Nothing (PEcall f_nm (List.map Caux.mk_value_pe arg_cvals)))
  ) in
  Exception.bind match f_nm with
    | Sym f_a ->
        match Map.lookup f_a file.stdlib with
          | Just z ->
              (* callign a function from the Core standard library *)
              Exception.return z
          | Nothing ->
              match Map.lookup f_a file.funs with
                | Just z ->
                    (* calling a user function *)
                    Exception.return z
                | Nothing ->
                    Exception.fail (Errors.Illformed_program "calling an unknown function")
              end
        end
    | Impl f ->
        match Map.lookup f file.impl with
          | Just (IFun bty params pe) ->
              Exception.return (Fun bty params pe)
          | _ ->
              Exception.fail (Errors.Illformed_program ("calling an unknown impl-function: " ^
                                                 Implementation.string_of_implementation_constant f))
        end
  end function
    | Fun _ params body_pe ->
        if List.length params <> List.length arg_cvals then
          error (
            (*  TODO: clean *)
            "CALL(" (*^ Pp.stringFromCore_value (Vobject (OVcfunction f_nm)) *)^
            ") |params|= " ^ show (List.length params) ^ " <> |args|= " ^ show (List.length arg_cvals)
          )
        else
          Exception.return $ Utils.foldl2 (fun acc (a, _) cval -> Caux.subst_sym_pexpr a cval acc) body_pe params arg_cvals
    | ProcDecl _ _ _ ->
        error "Core_eval.call_function, called on a ProcDecl"
    | BuiltinDecl _ _ _ ->
        error "Core_eval.call_function, called on a BuiltinDecl"
    | Proc _ _ _ _ _ ->
        error "Core_eval.call_function, called on a Proc"
  end


let inline (>>=)    = EU.bind
let inline (>>) m f = m >>= fun _ -> f
let inline (<$>) = EU.fmap


val step_eval_peop:
  Loc.t -> (Core.pexpr -> EU.t Core.pexpr Errors.core_run_cause) ->
  Core.binop -> Core.pexpr -> Core.pexpr  ->
  EU.t (Core.generic_pexpr_ Symbol.sym) Errors.core_run_cause

let step_eval_peop loc self binop pe1 pe2 =
  self pe1 >>= fun pe1' ->
  self pe2 >>= fun pe2' ->
  match (binop, Caux.valueFromPexpr pe1', Caux.valueFromPexpr pe2') with
        (* Ctype equality *)
        | (OpEq, Just (Vctype ty1), Just (Vctype ty2)) ->
            EU.return $ PEval (if ty1 = ty2 then Vtrue else Vfalse)
        
        (* Integer equality *)
        | (OpEq, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            match Mem.eq_ival ival1 ival2 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  EU.fail Errors.Constrained
            end

        | (OpEq, Just (Vobject (OVfloating fval1)), Just (Vobject (OVfloating fval2))) ->
            EU.return (PEval (if Mem.eq_fval fval1 fval2 then Vtrue else Vfalse))
        
        | (OpLt, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            match Mem.lt_ival ival1 ival2 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  EU.fail Errors.Constrained
            end

        | (OpLt, Just (Vobject (OVfloating fval1)), Just (Vobject (OVfloating fval2))) ->
            EU.return (PEval (if Mem.lt_fval fval1 fval2 then Vtrue else Vfalse))
        
        | (OpLe, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            match Mem.le_ival ival1 ival2 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  EU.fail Errors.Constrained
            end

        | (OpLe, Just (Vobject (OVfloating fval1)), Just (Vobject (OVfloating fval2))) ->
            EU.return (PEval (if Mem.le_fval fval1 fval2 then Vtrue else Vfalse))
        
        | (OpGe, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            (* TODO CHECK *)
            match Mem.le_ival ival2 ival1 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  EU.fail Errors.Constrained
            end

        | (OpGe, Just (Vobject (OVfloating fval1)), Just (Vobject (OVfloating fval2))) ->
            EU.return (PEval (if Mem.le_fval fval2 fval1 then Vtrue else Vfalse))
        
        | (OpGt, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            (* TODO CHECK *)
            match Mem.lt_ival ival2 ival1 with
              | Just b ->
                  EU.return (PEval (if b then Vtrue else Vfalse))
              | Nothing ->
                  EU.fail Errors.Constrained
            end

        | (OpGt, Just (Vobject (OVfloating fval1)), Just (Vobject (OVfloating fval2))) ->
            EU.return (PEval (if Mem.lt_fval fval2 fval1 then Vtrue else Vfalse))
        
        | (_, Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
            let iop = match binop with
              | OpAdd   -> Mem_common.IntAdd
              | OpSub   -> Mem_common.IntSub
              | OpMul   -> Mem_common.IntMul
              | OpDiv   -> Mem_common.IntDiv
              | OpRem_t -> Mem_common.IntRem_t
              | OpRem_f -> Mem_common.IntRem_f
              | OpExp   -> Mem_common.IntExp
              | _ ->
                  error ("Core_eval.eval_pexpr, PEop Vinteger Vinteger: " ^ show binop)
            end in
            EU.return (PEval (Vobject (OVinteger (Mem.op_ival iop ival1 ival2))))

        | (_, Just (Vobject (OVfloating fval1)), Just (Vobject (OVfloating fval2))) ->
            let fop = match binop with
              | OpAdd -> Mem_common.FloatAdd
              | OpSub -> Mem_common.FloatSub
              | OpMul -> Mem_common.FloatMul
              | OpDiv -> Mem_common.FloatDiv
              | _ ->
                error ("Core_eval.eval_pexpr, PEop Vfloating Vfloating " ^ show binop)
            end in
            EU.return (PEval (Vobject (OVfloating (Mem.op_fval fop fval1 fval2))))
        
        | (OpAnd, Just v1, Just v2) ->
            let v1 = (*Core_aux.flatten_constrained_value*) v1 in
            let v2 = (*Core_aux.flatten_constrained_value*) v2 in
            (* TODO: factorise *)
            match (v1, v2) with
              | (Vtrue, Vtrue) ->
                  EU.return (PEval Vtrue)
              | (Vtrue, Vfalse) ->
                  EU.return (PEval Vfalse)
              | (Vfalse, Vtrue) ->
                  EU.return (PEval Vfalse)
              | (Vfalse, Vfalse) ->
                  EU.return (PEval Vfalse)
(*
              | (Vtrue, Vconstrained xs) ->
                  (* true /\ constrained v --> constrained v *)
                  EU.return (PEval (Vconstrained (List.map (fun (consts, v) -> (consts, v)) xs)))
              | (Vfalse, Vconstrained xs) ->
                  (* false /\ constrained v --> false *)
                  EU.return (PEval Vfalse)
              | (Vconstrained xs, Vtrue) ->
                  (* constrained v /\ true --> constrained v *)
                  EU.return (PEval (Vconstrained (List.map (fun (consts, v) -> (consts, v)) xs)))
              | (Vconstrained xs, Vfalse) ->
                  (* constrained v /\ false --> false *)
                  EU.return (PEval Vfalse)
              | (Vconstrained xs1, Vconstrained xs2) ->
                  EU.return (
                    PEval (
                      Vconstrained $ List.map (fun ((cs1, v1'), (cs2, v2')) ->
                        (ND.concat cs1 cs1, match (v1', v2') with
                          | (Vtrue,  Vtrue)  -> Vtrue
                          | (Vtrue,  Vfalse) -> Vfalse
                          | (Vfalse, Vtrue)  -> Vfalse
                          | (Vfalse, Vfalse) -> Vfalse
                          | _ ->
                              (* this case is not possible thanks to the calls to [flatten_constrained_value] *)
                              error "Core_eval.step_eval_peop, OpAnd"
                         end)
                      ) (Utils.product_list xs1 xs2)
                    )
                  )
*)

              | _ ->
                  illformed_program ("[" ^ Loc.stringFromLocation loc ^ "] the two operands of /\\ should be booleans ==> " ^ Pp.stringFromCore_value v1 ^ " <-> " ^ Pp.stringFromCore_value v2)
            end
        
        | (OpOr, Just v1, Just v2) ->
            match (v1, v2) with
              | (Vtrue, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vtrue, Vfalse) ->
                  EU.return $ PEval Vtrue
              | (Vfalse, Vtrue) ->
                  EU.return $ PEval Vtrue
              | (Vfalse, Vfalse) ->
                  EU.return $ PEval Vfalse
              | _ ->
                  illformed_program ("[" ^ Loc.stringFromLocation loc ^ "] the two operands of \\/ should be booleans")
            end
        
        | (_, Just _, Just _) ->
            illformed_program ("[" ^ Loc.stringFromLocation loc ^ "] ill-typed PEop ==> " ^
              Pp.stringFromCore_pexpr (Caux.mk_op_pe binop pe1 pe2))
        | _ ->
(*
            let () = Debug.print_debug 1 [] (fun () ->
              Pp.stringFromCore_pexpr (Pexpr [] () (PEop binop pe1' pe2'))
            ) in
*)
            EU.return $ PEop binop pe1' pe2'
      end




(* evaluation of pure expressions (will crash on ill-typed and/or non pure
   expressions).  Note that this evaluation may be partial; that is, the
   result of eval may be another unevaluated expression rather than a value.
   This is to ensure that the eval function will always terminate (which is
   important for the Coq backend).  To fully evaluate a pure expression,
   it is necessary to call eval repeatedly until is_value returns True. *)
val     step_eval_pexpr: nat -> Loc.t -> maybe Loc.t ->
                         map Symbol.sym Symbol.sym ->
                         list (map Symbol.sym Core.value) ->
                         maybe Mem.mem_state -> Core.file core_run_annotation ->
                         bool -> Core.pexpr  ->
                         EU.t Core.pexpr Errors.core_run_cause
let rec step_eval_pexpr n loc parent_call_loc_opt core_extern env mem_st_opt file hasConstrained pexpr =
  match pexpr with Pexpr _ _ pexpr_  ->
  let strip (Pexpr _ _ pe_) = pe_ in
  let self pe =
    step_eval_pexpr (n+1) loc parent_call_loc_opt core_extern env mem_st_opt file (*hasConstrained *)false pe in
  Pexpr [] Nothing <$> match pexpr_ with
    | PEsym sym ->
        let sym = match Map.lookup sym core_extern with
          | Just sym -> sym
          | Nothing -> sym
        end in
        match Core_aux.lookup_env sym env with
          | Nothing ->
              (* NOTE: check if it is a procedure pointer *)
              match Map.lookup sym file.funs with
                | Just (Proc _ _ _ _ _) ->
                    EU.return (PEval (Vobject (OVpointer (Mem.null_ptrval (Ctype.Ctype [] Ctype.Void)))))
                | _ ->
                    EU.fail (Errors.Unresolved_symbol loc sym)
              end
          | Just cval ->
              EU.return (PEval cval)
        end
    | PEimpl iCst ->
        match Map.lookup iCst file.impl with
          | Just (Def _ pe) ->
              EU.return (strip pe)
          | _ ->
              EU.fail Errors.Unknown_impl
        end
    | PEval cval ->
        EU.return pexpr_
    | PEundef undef_loc ub ->
        let loc' =
          match (ub, parent_call_loc_opt) with
            | (Undefined.UB088_reached_end_of_function, Just call_loc) ->
                call_loc
            | _ ->
                if Loc.is_library_location undef_loc then loc else undef_loc
          end in
        Exception.return (Undefined.undef loc' [ub])
    | PEerror str debug_pe ->
        Exception.return (Undefined.error loc str)
    | PEctor ctor pes ->
        EU.mapM self pes >>= fun pes' ->
        match (ctor, Caux.valueFromPexprs pes') with
          | (Cnil bTy, Just []) ->
              EU.return $ PEval (Vlist bTy [])
          | (Ccons, Just [cval1; Vlist bTy' cvals]) ->
                EU.return $ PEval (Vlist bTy' (cval1 :: cvals))
          | (Ctuple, Just cvals) ->
              EU.return $ PEval (Vtuple cvals)
          | (Carray, Just cvals) ->
              (* By typing all the [cvals] must be loaded_values *)
              match List.foldr (fun cval acc ->
                match (cval, acc) with
                  | (Vloaded lval, Just lvals) ->
                      Just (lval :: lvals)
                  | _ ->
                      Nothing
                end
              ) (Just []) cvals with
                | Nothing ->
                    illformed_program ("PEctor, Carray: one of the operands didn't evaluate to a loaded value ==> " ^
                      stringFromList Pp.stringFromCore_value cvals)
                | Just lvals ->
                    EU.return (PEval (Vobject (OVarray lvals)))
              end
          | (Civmax, Just [Vctype ty]) ->
              match Ctype.unatomic_ ty with
                | (Ctype.Basic (Ctype.Integer ity)) ->
                    EU.return $ PEval (Vobject (OVinteger (Mem.max_ival ity)))
                | _ ->
                    error ("Core_eval ivmax" ^ (* DEBUG *)
                           Pp.stringFromCore_expr (Core.Expr [] (Core.Epure (Core.Pexpr [] Nothing (Core.PEval (Vctype ty)))) : Core.expr unit)) (* DEBUG *)
              end
          | (Civmin, Just [Vctype ty]) ->
              match Ctype.unatomic_ ty with
                | (Ctype.Basic (Ctype.Integer ity)) ->
                    EU.return $ PEval (Vobject (OVinteger (Mem.min_ival ity)))
                | _ ->
                    error ("Core_eval ivmin [" ^ Loc.stringFromLocation loc ^ "] ==> " ^ (* DEBUG *)
                               Pp.stringFromCore_expr (Core.Expr [] (Core.Epure (Core.Pexpr [] Nothing (Core.PEval (Vctype ty)))) : Core.expr unit)) (* DEBUG *)
              end
          | (Civsizeof, Just [Vctype ty]) ->
              EU.return $ PEval (Vobject (OVinteger (Mem.sizeof_ival ty)))
          | (Civalignof, Just [Vctype ty]) ->
              EU.return $ PEval (Vobject (OVinteger (Mem.alignof_ival ty)))
          | (CivCOMPL, Just [Vctype ty; Vobject (OVinteger ival)]) ->
              match Ctype.unatomic_ ty with
                | (Ctype.Basic (Ctype.Integer ity)) ->
                    EU.return $ PEval (Vobject (OVinteger (Mem.bitwise_complement_ival ity ival)))
                | _ ->
                    error "Core_Eval ivCOMPL, not (is_integer ty)"
              end
          | (CivAND, Just [Vctype ty; Vobject (OVinteger ival1); Vobject (OVinteger ival2)]) ->
              match Ctype.unatomic_ ty with
                | (Ctype.Basic (Ctype.Integer ity)) ->
                    EU.return $ PEval (Vobject (OVinteger (Mem.bitwise_and_ival ity ival1 ival2)))
                | _ ->
                    error "Core_Eval ivAND, not (is_integer ty)"
              end
          | (CivOR, Just [Vctype ty; Vobject (OVinteger ival1); Vobject (OVinteger ival2)]) ->
              match Ctype.unatomic_ ty with
                | (Ctype.Basic (Ctype.Integer ity)) ->
                    EU.return $ PEval (Vobject (OVinteger (Mem.bitwise_or_ival ity ival1 ival2)))
                | _ ->
                    error "Core_Eval ivOR, not (is_integer ty)"
              end
          | (CivXOR, Just [Vctype ty; Vobject (OVinteger ival1); Vobject (OVinteger ival2)]) ->
              match Ctype.unatomic_ ty with
                | (Ctype.Basic (Ctype.Integer ity)) ->
                    EU.return $ PEval (Vobject (OVinteger (Mem.bitwise_xor_ival ity ival1 ival2)))
                | _ ->
                    error "Core_Eval ivXOR, not (is_integer ty)"
              end
          | (Cspecified, Just [Vobject oval]) ->
              EU.return $ PEval (Vloaded (LVspecified oval))
          | (Cunspecified, Just [Vctype ty]) ->
              EU.return $ PEval (Vloaded (LVunspecified ty))

          | (Cfvfromint, Just [Vobject (OVinteger ival)]) ->
              EU.return $ PEval (Vobject (OVfloating (Mem.fvfromint ival)))
          | (Civfromfloat, Just [Vctype (Ctype.Ctype _ (Ctype.Basic (Ctype.Integer ity))); Vobject (OVfloating fval)]) ->
              EU.return $ PEval (Vobject (OVinteger (Mem.ivfromfloat ity fval)))

          | (CivNULLcap is_signed, Just []) ->
              EU.return $ PEval (Vobject (OVinteger (Mem.null_cap is_signed)))
          
          | (_, Just cvals) ->
              illformed_program ("PEctor: one of the operands was ill-typed ==> " ^
                Pp.stringFromCore_pexpr pexpr ^ " <====> " ^
                stringFromList Pp.stringFromCore_value cvals)
          | (_, Nothing) ->
              EU.return $ PEctor ctor pes'
        end
    | PEcase pe pat_pes ->
        self pe >>= function
          | Pexpr _ _ (PEval cval) ->
              match Caux.select_case Caux.subst_sym_pexpr cval pat_pes with
                | Just pe'' ->
                    EU.return (strip pe'')
                | Nothing ->
                    error ("PEcase, mismatched ==> [" ^ Loc.stringFromLocation loc ^ "]" ^ Pp.stringFromCore_value cval)
              end
          | pe' ->
              EU.return (PEcase pe' pat_pes)
        end
    | PEarray_shift pe1 ty pe2 ->
        self pe1 >>= fun pe1' ->
        self pe2 >>= fun pe2' ->
        match (Caux.valueFromPexpr pe1', Caux.valueFromPexpr pe2') with
          | (Just (Vobject (OVpointer ptr_val)), Just (Vobject (OVinteger ival))) ->
              EU.return $ PEval (Vobject (OVpointer (Mem.array_shift_ptrval ptr_val ty ival)))
          | (Just _, Just _) ->
              illformed_program ("PEarray_shift: type error ==> " ^
                Pp.stringFromCore_pexpr (Pexpr [] Nothing (PEarray_shift pe1' ty pe2')))
          | _ ->
              EU.return $ PEarray_shift pe1' ty pe2'
        end
    | PEmember_shift pe tag_sym member_ident ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vobject (OVpointer ptr_val)) ->
              EU.return $ PEval (Vobject (OVpointer (Mem.member_shift_ptrval ptr_val tag_sym member_ident)))
          | Just _ ->
              illformed_program "PEmember_shift"
          | _ ->
              EU.return $ PEmember_shift pe' tag_sym member_ident
        end
    | PEmemop memop pes ->
        EU.mapM self pes >>= fun pes' ->
        match (memop, Caux.valueFromPexprs pes') with
          | ( Mem_common.DeriveCap op is_signed
            , Just [ Core.Vobject (Core.OVinteger ival1)
                   ; Core.Vobject (Core.OVinteger ival2) ] ) ->
                EU.return (PEval (Vobject (OVinteger (Mem.derive_cap is_signed op ival1 ival2))))
          | ( Mem_common.CapAssignValue
            , Just [ Core.Vobject (Core.OVinteger ival1)
                   ; Core.Vobject (Core.OVinteger ival2) ] ) ->
             EU.return (PEval (Vobject (OVinteger (Mem.cap_assign_value loc ival1 ival2))))
          | ( Mem_common.Ptr_tIntValue
            , Just [ Core.Vobject (Core.OVinteger ival) ] ) ->
                EU.return (PEval (Vobject (OVinteger (Mem.ptr_t_int_value ival))))
          | ( Mem_common.ByteFromInt
            , Just [ Core.Vobject (Core.OVinteger ival) ] ) ->
                EU.return (PEval (Vobject (OVinteger (Mem.bytefromint loc ival))))
          | ( Mem_common.IntFromByte
            , Just [ Core.Vobject (Core.OVinteger ival) ] ) ->
                EU.return (PEval (Vobject (OVinteger (Mem.intfrombyte loc ival))))
          | (_, Just _) ->
              illformed_program "PEmemop"
          | (_, Nothing) ->
              EU.return (PEmemop memop pes')
        end        
    | PEnot (Pexpr annot pe_bTy _ as pe) ->
        self pe >>= fun (Pexpr annot pe_bTy pe_' as pe') ->
        match pe_' with
(*
          | PEval (Vconstrained xs) ->
              (PEval -| Vconstrained) <$> EU.mapM function
                | (cs, Vtrue) ->
                    EU.return (cs, Vfalse)
                | (cs, Vfalse) ->
                    EU.return (cs, Vtrue)
                | _ ->
                    illformed_program "PEnot: operand should be a boolean"
              end xs
*)
          | PEval Vtrue ->
              EU.return (PEval Vfalse)
          | PEval Vfalse ->
              EU.return (PEval Vtrue)
          | PEval _ ->
              illformed_program "PEnot: operand should be a boolean"
          | _ ->
              EU.return (PEnot pe')
        end
    | PEop binop pe1 pe2 ->
       step_eval_peop loc  self binop pe1 pe2
    | PEconv_int ity pe ->
        self pe >>= function
          | Pexpr _ _ (PEval (Vobject (OVinteger ival))) ->
              EU.return (PEval (Vobject (OVinteger (mk_conv_int ity ival))))
          | Pexpr _ _ (PEval _) ->
              illformed_program "PEconv_int: operand should be an object integer"
          | pe' ->
              EU.return (PEconv_int ity pe')
        end
    | PEwrapI ity iop pe1 pe2 ->
        self pe1 >>= fun pe1' ->
        self pe2 >>= fun pe2' ->
        match (Caux.valueFromPexpr pe1', Caux.valueFromPexpr pe2') with
          | (Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
              EU.return (PEval (Vobject (OVinteger (mk_wrapI_op ity iop ival1 ival2))))
          | (Just _, Just _) ->
              illformed_program "PEwrapI: operands should be an object integers"
            | _ ->
              EU.return (PEwrapI ity iop pe1' pe2')
        end
    | PEcatch_exceptional_condition ity iop pe1 pe2 ->
        self pe1 >>= fun pe1' ->
        self pe2 >>= fun pe2' ->
        match (Caux.valueFromPexpr pe1', Caux.valueFromPexpr pe2') with
          | (Just (Vobject (OVinteger ival1)), Just (Vobject (OVinteger ival2))) ->
              match mk_call_catch_exceptional_condition ity iop ival1 ival2 with
                | Just ival ->
                    EU.return (PEval (Vobject (OVinteger ival)))
                | Nothing ->
                    Exception.return (Undefined.undef loc [Undefined.UB036_exceptional_condition])
              end
          | (Just _, Just _) ->
              illformed_program "PEcatch_exceptional_condition: operands should be an object integers"
            | _ ->
              EU.return (PEcatch_exceptional_condition ity iop pe1' pe2')
        end
    | PEstruct tag_sym ident_pes ->
        let (idents, pes) = List.unzip ident_pes in
        EU.mapM self pes >>= fun pes' ->
        match Caux.valueFromPexprs pes' with
          | Just cvals ->
              let xs = List.map (fun (memb_ident, cval) ->
                match snd $ fromJust "Core_eval, PEstruct 1,1" (Map.lookup tag_sym file.tagDefs) with
                  | Ctype.StructDef membrs flexible_opt ->
                      (* let () = match flexible_opt with
                        | Nothing ->
                            ()
                        | Just (Ctype.FlexibleArrayMember _ flex_ident _ _) ->
                            (* TODO(check): PEstruct are only created at static init and struct a value loads, which should be ignoring any flexible array member *)
                            error "Core_eval, PEstruct => found a flexible array member"
                      end in *)
                      let (_, _, _, memb_ty) = fromJust "Core_eval, PEstruct 1" (List.lookup memb_ident membrs) in
                      let mval = fromJust "Core_Eval, PEstruct 2" (Caux.memValueFromValue memb_ty cval) in
                      (memb_ident, memb_ty, mval)
                  | Ctype.UnionDef _ ->
                      error "Core_eval.step_eval_pexpr, PEstruct found a UnionDef"
                end
              ) (List.zip idents cvals) in
              EU.return (PEval (Vobject (OVstruct tag_sym xs)))
(*
KKK:              EU.return (PEval (Vloaded (LVspecified (OVstruct tag_sym xs))))
*)
          | Nothing ->
              EU.return (PEstruct tag_sym (List.zip idents pes'))
        end
    | PEunion tag_sym memb_ident pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just cval ->
              match snd $ fromJust "Core_eval, PEunion 1,1" (Map.lookup tag_sym file.tagDefs) with
                | Ctype.UnionDef membrs ->
                    let (_, _, _, memb_ty) = fromJust "Core_eval, PEunion 1" (List.lookup memb_ident membrs) in
                    let mval = fromJust "Core_Eval, PEunion 2" (Caux.memValueFromValue memb_ty cval) in
                    EU.return (PEval (Vobject (OVunion tag_sym memb_ident mval)))
                | Ctype.StructDef _ _ ->
                      error "Core_eval.step_eval_pexpr, PEunion found a StructDef"
                end
          | Nothing ->
              EU.return (PEunion tag_sym memb_ident pe')
        end
    | PEcfunction pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vloaded (LVspecified (OVpointer pv))) ->
              let case_funptrval = function
                | Just sym ->
                    let () = Debug.print_debug 3 [] (fun () -> "function pointer: " ^ show sym) in
                    match Map.lookup sym file.funinfo with
                      | Just (_, _, ret, params, is_variadic, has_proto) ->
                          let () = Debug.print_debug 3 [] (fun () -> "function pointer (lookup): " ^ show sym) in
                          EU.return (PEval (Vtuple [Vctype ret;
                                                    Vlist BTy_ctype (List.map (fun (_, ty) -> Vctype ty) params);
                                                    if is_variadic then Vtrue else Vfalse;
                                                    if has_proto then Vtrue else Vfalse; ]))
                      | _ ->
                        illformed_program (Loc.stringFromLocation loc ^ ": '" ^ show sym ^ "' does not point to a function (cfunction)")
                    end
                | Nothing ->
                  let ub = Undefined.UB_CERB003_invalid_function_pointer in
                  Exception.return (Undefined.undef loc [ub])
              end in
              Mem.case_ptrval pv
                (fun _ -> illformed_program "null function pointer")
                case_funptrval
                (fun _ _ ->
                (* TODO: not sure about this case! it happens when calling a function pointer casted to void* via: ((void ( * )(void))p)(); *)
                  match mem_st_opt with
                  | Just mem_st ->
                      match Mem.case_funsym_opt mem_st pv with
                      | Just sym ->
                          case_funptrval (Just sym)
                      | Nothing ->
                          illformed_program (Loc.stringFromLocation loc ^ ": does not point to a function")
                      end
                  | Nothing ->
                      illformed_program (Loc.stringFromLocation loc ^ ": does not point to a function")
                  end)
          | Just (Vloaded (LVunspecified _)) ->
              illformed_program "function pointer has an unspecified value"
          | _ ->
            error "Core_eval.step_eval_pexpr, PEcfunction expects a pointer"
        end
    | PEmemberof tag_sym memb_ident pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vobject (OVstruct tag_sym' xs)) ->
              if tag_sym <> tag_sym' then
                illformed_program ("PEmemberof(struct) ==> mismatched tags: " ^ show tag_sym ^ " vs " ^ show tag_sym')
              else match List.lookup memb_ident (List.map (fun (a,_,b) -> (a,b)) xs) with
                | Nothing ->
                    illformed_program ("PEmemberof ==> invalid member: " ^ show memb_ident)
                | Just mval ->
                    EU.return (PEval (snd (Caux.valueFromMemValue mval)))
              end
          | Just (Vobject (OVunion tag_sym' memb_ident' mval)) ->
              if tag_sym <> tag_sym' then
                illformed_program ("PEmemberof(union) ==> mismatched tags: " ^ show tag_sym ^ " vs " ^ show tag_sym')
              else if memb_ident <> memb_ident' then
                error "TODO: evaluation of PEmemberof => union puning"
              else
                EU.return (PEval (snd (Caux.valueFromMemValue mval)))
          | Just cval ->
              illformed_program ("PEmemberof ==> " ^ Pp.stringFromCore_value cval)
          | Nothing ->
              EU.return (PEmemberof tag_sym memb_ident pe')
        end
    | PEcall nm pes ->
        EU.mapM self pes >>= fun pes' ->
        match Caux.valueFromPexprs pes' with
          | Just cvals ->
              (* We do not immediately call eval on the result of call_function,
                 as that could lead to non-termination. *)
              Exception.bind (call_function file nm cvals) (fun (Pexpr _ _ pe_) ->
                (* TODO: maybe annyoing to have stripping if we want a proof of type preservation? *)
                EU.return pe_)
          | Nothing ->
              EU.return (PEcall nm pes')
        end
    | PElet pat pe1 pe2 ->
        self pe1 >>= function
          | Pexpr _ _ (PEval cval) ->
              match Caux.select_case Caux.subst_sym_pexpr cval [(pat, pe2)] with
                | Nothing ->
                    illformed_program "PElet: the pattern didn't match pe1"
                | Just pe' ->
                    EU.return $ strip pe'
              end
          | pe1' ->
              EU.return $ PElet pat pe1' pe2
        end
    | PEif pe1 pe2 pe3 ->
        (* let () = Debug.print_debug 5 [] (fun () ->
          "Core_eval ==> PEif (_) ==> " ^ Pp.stringFromCore_pexpr pexpr
        ) in *)
        self pe1 >>= fun pe1' ->
        match Caux.valueFromPexpr pe1' with
          | Just Vtrue ->
              strip <$> self pe2
          | Just Vfalse ->
              strip <$> self pe3
          | Just cval ->
              illformed_program ("PEif: first operand should be a boolean ==> " ^ Pp.stringFromCore_value cval)
          | Nothing ->
              EU.return $ PEif pe1' pe2 pe3
        end
    | PEis_scalar pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vctype ty) ->
              EU.return $ PEval (if AilTypesAux.is_scalar ty then Vtrue else Vfalse)
          | Just _ ->
              illformed_program "PEis_scalar: the operand should be a ctype"
          | Nothing ->
              EU.return $ PEis_scalar pe'
        end
    | PEis_integer pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vctype ty) ->
              EU.return $ PEval (if AilTypesAux.is_integer ty then Vtrue else Vfalse)
          | Just _ ->
              illformed_program "PEis_integer: the operand should be a ctype"
          | Nothing ->
              EU.return $ PEis_scalar pe'
        end
    | PEis_signed pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vctype ty) ->
              EU.return $ PEval (if AilTypesAux.is_signed_integer_type ty then Vtrue else Vfalse)
          | Just _ ->
              illformed_program "PEis_signed: the operand should be a ctype"
          | Nothing ->
              EU.return $ PEis_scalar pe'
        end
    | PEis_unsigned pe ->
        self pe >>= fun pe' ->
        match Caux.valueFromPexpr pe' with
          | Just (Vctype ty) ->
              EU.return $ PEval (if AilTypesAux.is_unsigned_integer_type ty then Vtrue else Vfalse)
          | Just _ ->
              illformed_program "PEis_unsigned: the operand should be a ctype"
          | Nothing ->
              EU.return $ PEis_scalar pe'
        end
    | PEbmc_assume pe ->
      illformed_program "PEbmc_assume: __bmc_assume is for model checking only"
    | PEare_compatible pe1 pe2 ->
        self pe1 >>= fun pe1 ->
        self pe2 >>= fun pe2 ->
        match (Caux.valueFromPexpr pe1, Caux.valueFromPexpr pe2) with
          | (Just (Vctype ty1), Just (Vctype ty2)) ->
              let are_compatible =
                AilTypesAux.are_compatible
                  (Ctype.no_qualifiers, ty1)
                  (Ctype.no_qualifiers, ty2) in
              EU.return $ PEval (if are_compatible then Vtrue else Vfalse)
          | (_, _) ->
              illformed_program "PEare_compatible: the operands should be ctypes"
        end
  end
  end




val     eval_pexpr_aux2: Loc.t -> maybe Loc.t -> 
                         map Symbol.sym Symbol.sym ->
                         list (map Symbol.sym Core.value) ->
                         maybe Mem.mem_state -> Core.file core_run_annotation ->
                         Core.pexpr ->
                         EU.t (either Core.pexpr Core.value) Errors.core_run_cause
let rec eval_pexpr_aux2 loc current_call_loc_opt core_extern env mem_st_opt file pe =
  step_eval_pexpr 0 loc current_call_loc_opt core_extern env mem_st_opt file false pe >>= fun pe' ->
  match Caux.valueFromPexpr pe' with
    | Just cval ->
        EU.return (Right cval)
    | Nothing ->
        eval_pexpr_aux2 loc current_call_loc_opt core_extern env mem_st_opt file pe'
  end










(* ============================================================================================== *)

























val eval_pexpr_aux_broken:
  Loc.t -> maybe Loc.t -> 
  map Symbol.sym Symbol.sym ->
  list (map Symbol.sym Core.value) ->
  maybe Mem.mem_state -> Core.file core_run_annotation ->
  Core.pexpr ->
  EU.t Core.value Errors.core_run_cause
let rec eval_pexpr_aux_broken loc current_call_loc_opt core_extern env mem_st_opt file pe =
  step_eval_pexpr 0 loc current_call_loc_opt core_extern env mem_st_opt file false ((* let ()=Debug.print_debug 5 [] (fun () -> "BOOM") in*) pe) >>= fun pe' ->
  match Caux.valueFromPexpr pe' with
    | Just cval ->
        EU.return cval
    | Nothing ->
        eval_pexpr_aux_broken loc current_call_loc_opt core_extern env mem_st_opt file pe'
  end
val eval_pexpr: Loc.t -> maybe Loc.t -> map Symbol.sym Symbol.sym ->
                list (map Symbol.sym Core.value) -> maybe Mem.mem_state -> Core.file core_run_annotation ->
                Core.pexpr -> either Errors.error (Undefined.t Core.value)
let eval_pexpr loc current_call_loc_opt core_extern env mem_st_opt file pe =
  match eval_pexpr_aux_broken loc current_call_loc_opt core_extern env mem_st_opt file pe with
    | Exception.Result z ->
        Right z
    | Exception.Exception err ->
        Left (Errors.core_run_error loc err)
  end
