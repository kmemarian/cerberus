open import Pervasives
import Map_extra

open import Utils Exception Core
import Errors

type eff 'a = Exception.exceptM 'a Errors.error
include Exception

val mapMapM: forall 'k 'a 'b. MapKeyType 'k, SetType 'k, SetType 'a =>
             ('k -> 'a -> eff 'b) -> map 'k 'a -> eff (map 'k 'b)
let mapMapM f xs =
  Map_extra.fold (fun k a acc ->
    bind (f k a) (fun b ->
      bind acc (fun bs ->
        return (Map.insert k b bs)
      )
    )
  ) xs (return Map.empty)

val runM: forall 'a. eff 'a -> Exception.exceptM 'a Errors.error
let runM m = m

val fail: forall 'a. Loc.t -> Errors.core_typing_cause -> eff 'a
let core_typing_effect_fail loc cause =
  Exception (Errors.core_typing_error loc cause)
let inline fail = core_typing_effect_fail

(* NOTE: this is different than trysM, since it checks all the cases *)
val     trysM_: forall 'a 'b. Loc.t -> Errors.core_typing_cause -> ('a -> eff 'b) -> list 'a -> eff 'b
let rec trysM_ loc err f = function
  | [] -> fail loc err
  | x::xs ->
    match f x with
    | Result b -> Result b
    | Exception _ -> trysM_ loc err f xs
    end
  end

val guard: bool -> Loc.t ->  Errors.core_typing_cause -> eff unit
let core_typing_effect_guard pred loc cause =
  if pred then
    return ()
  else
    Exception (Errors.core_typing_error loc cause)
let inline guard = core_typing_effect_guard
(* BUG in Lem (see issue #197)
      fail loc cause
 *)

val foldlM: forall 'a 'b. ('a -> 'b -> eff 'a) -> 'a -> list 'b -> eff 'a
let rec core_typing_effect_foldlM f b = function
  | [] ->
      return b
  | x :: xs ->
      bind (f b x) (fun z -> core_typing_effect_foldlM f z xs)
end
let inline foldlM = core_typing_effect_foldlM


(* UndefinedStartup *)

let mismatch loc info_str expected_bTy found_bTy =
  fail loc (Errors.Mismatch info_str expected_bTy found_bTy)

(* MismatchBinaryOperator  *)
(* MismatchIf *)

let mismatch_expected loc info_str expected_bTy found_str =
  fail loc (Errors.MismatchExpected info_str expected_bTy found_str)

let mismatch_found loc info_str expected_str found_bTy =
  fail loc (Errors.MismatchFound info_str expected_str found_bTy)

let unresolved_symbol loc nm =
  fail loc (Errors.UnresolvedSymbol nm)

let function_or_procedure_symbol loc sym =
  fail loc (Errors.FunctionOrProcedureSymbol sym)

let too_general loc =
  fail loc Errors.TooGeneral

let fail_TODO loc str =
  fail loc (Errors.CoreTyping_TODO str)

let heterogenous_list loc expected_bTy found_bTy =
 fail loc (Errors.HeterogenousList expected_bTy found_bTy)

let invalid_tag loc tag_sym =
  fail loc (Errors.InvalidTag tag_sym)

let invalid_member loc tag_sym memb_ident =
  fail loc (Errors.InvalidMember tag_sym memb_ident)
