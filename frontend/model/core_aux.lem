open import Pervasives Utils Core Ctype
import Mem Mem_common Cmm_csem Linux Symbol Annot

declare {ocaml} rename module = lem_core_aux

val valueFromMemValue: Mem.mem_value -> core_object_type * value
val memValueFromValue: ctype -> value -> maybe Mem.mem_value
val loadedValueFromMemValue: Mem.mem_value -> core_object_type * loaded_value
declare ocaml target_rep function valueFromMemValue = `Core_aux.valueFromMemValue`
declare ocaml target_rep function memValueFromValue = `Core_aux.memValueFromValue`
declare ocaml target_rep function loadedValueFromMemValue = `Core_aux.loadedValueFromMemValue`

val core_object_type_of_ctype: ctype -> maybe core_object_type
declare ocaml target_rep function core_object_type_of_ctype = `Core_aux.core_object_type_of_ctype`


val valueFromPexpr: pexpr -> maybe value
val valueFromPexprs: list pexpr -> maybe (list value)
val to_pure: forall 'a. expr 'a -> maybe pexpr
declare ocaml target_rep function valueFromPexpr = `Core_aux.valueFromPexpr`
declare ocaml target_rep function valueFromPexprs = `Core_aux.valueFromPexprs`
declare ocaml target_rep function to_pure = `Core_aux.to_pure`


(* Core pattern builders  ************************************************** *)
val mk_empty_pat: core_base_type -> pattern
val mk_sym_pat: Symbol.sym -> core_base_type -> pattern
val mk_tuple_pat: list pattern -> pattern
val mk_specified_pat: pattern -> pattern
val mk_unspecified_pat: pattern -> pattern
declare ocaml target_rep function mk_empty_pat = `Core_aux.mk_empty_pat`
declare ocaml target_rep function mk_sym_pat = `Core_aux.mk_sym_pat`
declare ocaml target_rep function mk_tuple_pat = `Core_aux.mk_tuple_pat`
declare ocaml target_rep function mk_specified_pat = `Core_aux.mk_specified_pat`
declare ocaml target_rep function mk_unspecified_pat = `Core_aux.mk_unspecified_pat`


(* Core pexpr builders  ***************************************************** *)
val mk_sym_pe: Symbol.sym -> pexpr
val mk_integer_pe: integer -> pexpr
val mk_floating_value_pe: Mem.floating_value -> pexpr
val mk_nullptr_pe: ctype -> pexpr
val mk_specified_pe: pexpr -> pexpr
val mk_unspecified_pe: ctype -> pexpr
val mk_array_pe: list pexpr -> pexpr
val mk_unit_pe: pexpr
val mk_boolean_pe: bool -> pexpr
val mk_ail_ctype_pe: ctype -> pexpr
val mk_ctype_pe: ctype -> pexpr
val mk_list_pe: core_base_type -> list pexpr -> pexpr
val mk_tuple_pe: list pexpr -> pexpr
val mk_ivmax_pe: pexpr -> pexpr
(* val mk_ivmin_pe: pexpr -> pexpr *)
val mk_sizeof_pe: pexpr -> pexpr
val mk_alignof_pe: pexpr -> pexpr
val mk_nullcap_pe: bool -> pexpr
val mk_undef_pe: Loc.t -> Undefined.undefined_behaviour -> pexpr
val mk_error_pe: string -> pexpr -> pexpr
val mk_not_pe: pexpr -> pexpr
val mk_op_pe: binop -> pexpr -> pexpr -> pexpr
val mk_conv_int_pe: integerType -> pexpr -> pexpr
val mk_wrapI_pe: integerType -> iop -> pexpr -> pexpr -> pexpr
val mk_catch_exceptional_condition_pe: integerType -> iop -> pexpr -> pexpr -> pexpr
val mk_let_pe: pattern -> pexpr -> pexpr -> pexpr
val mk_if_pe: pexpr -> pexpr -> pexpr -> pexpr
val mk_array_shift: pexpr -> ctype -> pexpr -> pexpr
val mk_member_shift_pe: pexpr -> Symbol.sym -> Symbol.identifier -> pexpr
val mk_memop_pe: Mem_common.pure_memop -> list pexpr -> pexpr
val mk_case_pe: pexpr -> list (pattern * pexpr) -> pexpr

(* integerType is the type annotation placed on the 0 literal *)
(* TODO: in the move to OCaml, have mk_integer_pe take an optional integerType
 * instead of doing something special here
 *)
val mk_neg_pe: integerType -> pexpr -> pexpr

val mk_struct_pe: Symbol.sym -> list (Symbol.identifier * pexpr) -> pexpr
val mk_union_pe: Symbol.sym -> Symbol.identifier -> pexpr -> pexpr
val mk_memberof_pe: Symbol.sym -> Symbol.identifier -> pexpr -> pexpr
val mk_value_pe: value -> pexpr
val mk_cfunction_pe: pexpr -> pexpr
val mk_std_pe: string -> pexpr -> pexpr
val mk_std_undef_pe: Loc.t -> string -> Undefined.undefined_behaviour -> pexpr
val mk_std_pair_pe: string -> pexpr * pexpr -> pexpr * pexpr
val mk_call_pe: name -> list pexpr -> pexpr
val mk_are_compatible: pexpr -> pexpr -> pexpr
declare ocaml target_rep function mk_sym_pe = `Core_aux.mk_sym_pe`
declare ocaml target_rep function mk_integer_pe = `Core_aux.mk_integer_pe`
declare ocaml target_rep function mk_floating_value_pe = `Core_aux.mk_floating_value_pe`
declare ocaml target_rep function mk_nullptr_pe = `Core_aux.mk_nullptr_pe`
declare ocaml target_rep function mk_specified_pe = `Core_aux.mk_specified_pe`
declare ocaml target_rep function mk_unspecified_pe = `Core_aux.mk_unspecified_pe`
declare ocaml target_rep function mk_array_pe = `Core_aux.mk_array_pe`
declare ocaml target_rep function mk_unit_pe = `Core_aux.mk_unit_pe`
declare ocaml target_rep function mk_boolean_pe = `Core_aux.mk_boolean_pe`
declare ocaml target_rep function mk_ail_ctype_pe = `Core_aux.mk_ail_ctype_pe`
declare ocaml target_rep function mk_ctype_pe = `Core_aux.mk_ctype_pe`
declare ocaml target_rep function mk_list_pe = `Core_aux.mk_list_pe`
declare ocaml target_rep function mk_tuple_pe = `Core_aux.mk_tuple_pe`
declare ocaml target_rep function mk_ivmax_pe = `Core_aux.mk_ivmax_pe`
(* declare ocaml target_rep function mk_ivmin_pe = `Core_aux.mk_ivmin_pe` *)
declare ocaml target_rep function mk_sizeof_pe = `Core_aux.mk_sizeof_pe`
declare ocaml target_rep function mk_alignof_pe = `Core_aux.mk_alignof_pe`
declare ocaml target_rep function mk_nullcap_pe = `Core_aux.mk_nullcap_pe`
declare ocaml target_rep function mk_undef_pe = `Core_aux.mk_undef_pe`
declare ocaml target_rep function mk_error_pe = `Core_aux.mk_error_pe`
declare ocaml target_rep function mk_not_pe = `Core_aux.mk_not_pe`
declare ocaml target_rep function mk_op_pe = `Core_aux.mk_op_pe`
declare ocaml target_rep function mk_conv_int_pe = `Core_aux.mk_conv_int_pe`
declare ocaml target_rep function mk_wrapI_pe = `Core_aux.mk_wrapI_pe`
declare ocaml target_rep function mk_catch_exceptional_condition_pe = `Core_aux.mk_catch_exceptional_condition_pe`
declare ocaml target_rep function mk_let_pe = `Core_aux.mk_let_pe`
declare ocaml target_rep function mk_if_pe = `Core_aux.mk_if_pe`
declare ocaml target_rep function mk_array_shift = `Core_aux.mk_array_shift`
declare ocaml target_rep function mk_member_shift_pe = `Core_aux.mk_member_shift_pe`
declare ocaml target_rep function mk_memop_pe = `Core_aux.mk_memop_pe`
declare ocaml target_rep function mk_case_pe = `Core_aux.mk_case_pe`
declare ocaml target_rep function mk_neg_pe = `Core_aux.mk_neg_pe`
declare ocaml target_rep function mk_struct_pe = `Core_aux.mk_struct_pe`
declare ocaml target_rep function mk_union_pe = `Core_aux.mk_union_pe`
declare ocaml target_rep function mk_memberof_pe = `Core_aux.mk_memberof_pe`
declare ocaml target_rep function mk_value_pe = `Core_aux.mk_value_pe`
declare ocaml target_rep function mk_cfunction_pe = `Core_aux.mk_cfunction_pe`
declare ocaml target_rep function mk_std_pe = `Core_aux.mk_std_pe`
declare ocaml target_rep function mk_std_undef_pe = `Core_aux.mk_std_undef_pe`
declare ocaml target_rep function mk_std_pair_pe = `Core_aux.mk_std_pair_pe`
declare ocaml target_rep function mk_call_pe = `Core_aux.mk_call_pe`
declare ocaml target_rep function mk_are_compatible = `Core_aux.mk_are_compatible`

val mk_undef_exceptional_condition: Loc.t -> pexpr
val bitwise_complement_pe: pexpr -> pexpr -> pexpr
val bitwise_AND_pe: pexpr -> pexpr -> pexpr -> pexpr
val bitwise_OR_pe: pexpr -> pexpr -> pexpr -> pexpr
val bitwise_XOR_pe: pexpr -> pexpr -> pexpr -> pexpr
val mk_ivfromfloat_pe: pexpr -> pexpr -> pexpr
val mk_fvfromint_pe: pexpr -> pexpr
declare ocaml target_rep function mk_undef_exceptional_condition = `Core_aux.mk_undef_exceptional_condition`
declare ocaml target_rep function bitwise_complement_pe = `Core_aux.bitwise_complement_pe`
declare ocaml target_rep function bitwise_AND_pe = `Core_aux.bitwise_AND_pe`
declare ocaml target_rep function bitwise_OR_pe = `Core_aux.bitwise_OR_pe`
declare ocaml target_rep function bitwise_XOR_pe = `Core_aux.bitwise_XOR_pe`
declare ocaml target_rep function mk_ivfromfloat_pe = `Core_aux.mk_ivfromfloat_pe`
declare ocaml target_rep function mk_fvfromint_pe = `Core_aux.mk_fvfromint_pe`


(* Core expr builders ****************************************************** *)
val mk_pure_e: forall 'a. pexpr -> expr 'a
val mk_value_e: forall 'a. value -> expr 'a
val mk_skip_e: expr unit
val mk_unseq_e: forall 'a. list (expr 'a) -> expr 'a
val mk_case_e: pexpr -> list (pattern * expr unit) -> expr unit
val mk_wseq_e: forall 'a. pattern -> expr 'a -> expr 'a -> expr 'a
val mk_sseq_e: forall 'a. pattern -> expr 'a -> expr 'a -> expr 'a
val mk_save_e_: list Annot.annot -> (Symbol.sym * core_base_type) -> list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) -> expr unit -> expr unit
(* val mk_save_e: (Symbol.sym * core_base_type) -> list (Symbol.sym * ((core_base_type * maybe (Ctype.ctype * pass_by_value_or_pointer)) * pexpr)) -> expr unit -> expr unit *)
val mk_run_e: Symbol.sym -> list pexpr -> expr unit
val mk_nd_e: list (expr unit) -> expr unit
val mk_if_e_: list Annot.annot -> pexpr -> expr unit -> expr unit -> expr unit
val mk_if_e: pexpr -> expr unit -> expr unit -> expr unit
val mk_let_e: pattern -> pexpr -> expr unit -> expr unit
val mk_ccall_e_: list Annot.annot -> pexpr -> pexpr -> list pexpr -> expr unit
val mk_memop_e: Mem_common.memop -> list pexpr -> expr unit
val mk_wait_e: forall 'a. Mem_common.thread_id -> expr 'a

declare ocaml target_rep function mk_pure_e = `Core_aux.mk_pure_e`
declare ocaml target_rep function mk_value_e = `Core_aux.mk_value_e`
declare ocaml target_rep function mk_skip_e = `Core_aux.mk_skip_e`
declare ocaml target_rep function mk_unseq_e = `Core_aux.mk_unseq_e`
declare ocaml target_rep function mk_case_e = `Core_aux.mk_case_e`
declare ocaml target_rep function mk_wseq_e = `Core_aux.mk_wseq_e`
declare ocaml target_rep function mk_sseq_e = `Core_aux.mk_sseq_e`
declare ocaml target_rep function mk_save_e_ = `Core_aux.mk_save_e_`
(* declare ocaml target_rep function mk_save_e = `Core_aux.mk_save_e` *)
declare ocaml target_rep function mk_run_e = `Core_aux.mk_run_e`
declare ocaml target_rep function mk_nd_e = `Core_aux.mk_nd_e`
declare ocaml target_rep function mk_if_e_ = `Core_aux.mk_if_e_`
declare ocaml target_rep function mk_if_e = `Core_aux.mk_if_e`
declare ocaml target_rep function mk_let_e = `Core_aux.mk_let_e`
declare ocaml target_rep function mk_ccall_e_ = `Core_aux.mk_ccall_e_`
declare ocaml target_rep function mk_memop_e = `Core_aux.mk_memop_e`
declare ocaml target_rep function mk_wait_e = `Core_aux.mk_wait_e`


(* Core expr "smart" builders ************************************************)
val mk_unseq: forall 'a. list (expr 'a) -> expr 'a
val mk_unit_sseq: list (expr unit) -> (expr unit -> expr unit)
val mk_sseqs: list (pattern * expr unit) -> (expr unit -> expr unit)
declare ocaml target_rep function mk_unseq = `Core_aux.mk_unseq`
declare ocaml target_rep function mk_unit_sseq = `Core_aux.mk_unit_sseq`
declare ocaml target_rep function mk_sseqs = `Core_aux.mk_sseqs`

val concat_sseq: forall 'a. expr 'a -> expr 'a -> expr 'a
declare ocaml target_rep function concat_sseq = `Core_aux.concat_sseq`


(* Core (positive) memory action builders **************************************)
val pcreate: Loc.t -> pexpr -> pexpr -> Symbol.prefix -> expr unit
val pcreate_readonly: Loc.t -> pexpr -> pexpr -> pexpr -> Symbol.prefix -> expr unit
val pkill: Loc.t -> kill_kind -> pexpr -> expr unit
val pstore: Loc.t -> pexpr -> pexpr -> pexpr -> Cmm_csem.memory_order -> expr unit
val pstore_lock: Loc.t -> pexpr -> pexpr -> pexpr -> Cmm_csem.memory_order -> expr unit
val pload: Loc.t -> pexpr -> pexpr -> Cmm_csem.memory_order -> expr unit
(* val prmw: forall 'a. Loc.t ->  ty x n1 n2 mo1 mo2 = *)
val pcompare_exchange_strong: Loc.t -> pexpr -> pexpr -> pexpr -> pexpr -> Cmm_csem.memory_order -> Cmm_csem.memory_order -> expr unit
val pcompare_exchange_weak: Loc.t -> pexpr -> pexpr -> pexpr -> pexpr -> Cmm_csem.memory_order -> Cmm_csem.memory_order -> expr unit
val plinux_load: Loc.t -> pexpr -> pexpr -> Linux.linux_memory_order -> expr unit
val plinux_store: Loc.t -> pexpr -> pexpr -> pexpr -> Linux.linux_memory_order -> expr unit
val plinux_rmw: Loc.t -> pexpr -> pexpr -> pexpr -> Linux.linux_memory_order -> expr unit
declare ocaml target_rep function pcreate = `Core_aux.pcreate`
declare ocaml target_rep function pcreate_readonly = `Core_aux.pcreate_readonly`
declare ocaml target_rep function pkill = `Core_aux.pkill`
declare ocaml target_rep function pstore = `Core_aux.pstore`
declare ocaml target_rep function pstore_lock = `Core_aux.pstore_lock`
declare ocaml target_rep function pload = `Core_aux.pload`
(* declare ocaml target_rep function prmw = `Core_aux.prmw` *)
declare ocaml target_rep function pcompare_exchange_strong = `Core_aux.pcompare_exchange_strong`
declare ocaml target_rep function pcompare_exchange_weak = `Core_aux.pcompare_exchange_weak`
declare ocaml target_rep function plinux_load = `Core_aux.plinux_load`
declare ocaml target_rep function plinux_store = `Core_aux.plinux_store`
declare ocaml target_rep function plinux_rmw = `Core_aux.plinux_rmw`

val seq_rmw: Loc.t -> bool ->
  pexpr -> Core.core_object_type ->
  pexpr -> Symbol.sym -> pexpr ->
  expr unit
declare ocaml target_rep function seq_rmw = `Core_aux.seq_rmw`


(* Substitutions and pattern matching *)
val subst_sym_pexpr: Symbol.sym -> value -> pexpr -> pexpr
val subst_sym_expr: forall 'a. Symbol.sym -> value -> expr 'a -> expr 'a
val subst_wait: forall 'a. Mem_common.thread_id -> value -> expr 'a -> expr 'a
declare ocaml target_rep function subst_sym_pexpr = `Core_aux.subst_sym_pexpr`
declare ocaml target_rep function subst_sym_expr = `Core_aux.subst_sym_expr`
declare ocaml target_rep function subst_wait = `Core_aux.subst_wait`

val subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> maybe (expr 'a)
val unsafe_subst_pattern: forall 'a. pattern -> pexpr -> expr 'a -> expr 'a
val unsafe_subst_sym_pexpr: Symbol.sym -> pexpr -> pexpr -> pexpr
val unsafe_subst_sym_expr: forall 'a. Symbol.sym -> pexpr -> expr 'a -> expr 'a
declare ocaml target_rep function subst_pattern = `Core_aux.subst_pattern`
declare ocaml target_rep function unsafe_subst_pattern = `Core_aux.unsafe_subst_pattern`
declare ocaml target_rep function unsafe_subst_sym_pexpr = `Core_aux.unsafe_subst_sym_pexpr`
declare ocaml target_rep function unsafe_subst_sym_expr = `Core_aux.unsafe_subst_sym_expr`

val select_case: forall 'a. (Symbol.sym -> value -> 'a -> 'a) -> value -> list (pattern * 'a) -> maybe 'a
declare ocaml target_rep function select_case = `Core_aux.select_case`


(* Annotations and attributes *)
val add_loc: Loc.t -> expr unit -> expr unit
val add_stmt: expr unit -> expr unit
val add_expr: expr unit -> expr unit
val add_std: string -> expr unit -> expr unit
val add_stds: list string -> expr unit -> expr unit
declare ocaml target_rep function add_loc = `Core_aux.add_loc`
declare ocaml target_rep function add_stmt = `Core_aux.add_stmt`
declare ocaml target_rep function add_expr = `Core_aux.add_expr`
declare ocaml target_rep function add_std = `Core_aux.add_std`
declare ocaml target_rep function add_stds = `Core_aux.add_stds`

val add_attrs: Annot.attributes -> expr unit -> expr unit
val add_annot: Annot.annot -> expr unit -> expr unit
val add_annots: list Annot.annot -> expr unit -> expr unit
declare ocaml target_rep function add_attrs = `Core_aux.add_attrs`
declare ocaml target_rep function add_annot = `Core_aux.add_annot`
declare ocaml target_rep function add_annots = `Core_aux.add_annots`

val annotate_integer_type_pexpr : integerType -> pexpr -> pexpr
val maybe_annotate_integer_type_pexpr : ctype -> pexpr -> pexpr
val maybe_annotate_integer_type : ctype -> expr unit -> expr unit
declare ocaml target_rep function annotate_integer_type_pexpr = `Core_aux.annotate_integer_type_pexpr`
declare ocaml target_rep function maybe_annotate_integer_type_pexpr = `Core_aux.maybe_annotate_integer_type_pexpr`
declare ocaml target_rep function maybe_annotate_integer_type = `Core_aux.maybe_annotate_integer_type`

val lookup_env: Symbol.sym -> list (map Symbol.sym value) -> maybe value
val update_env: pattern -> value -> list (map Symbol.sym value) -> list (map Symbol.sym value)
declare ocaml target_rep function lookup_env = `Core_aux.lookup_env`
declare ocaml target_rep function update_env = `Core_aux.update_env`


val collect_labeled_continuations_NEW: forall 'a. file 'a -> map Symbol.sym (map Symbol.sym (list (Symbol.sym * core_base_type) * expr 'a))
declare ocaml target_rep function collect_labeled_continuations_NEW = `Core_aux.collect_labeled_continuations_NEW`
