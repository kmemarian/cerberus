open import Pervasives
import Map_extra

open import Utils Exception Core Errors

import Core_typing_effect
module E = Core_typing_effect

let inline (>>=)      = E.bind
let inline (>>) m1 m2 = m1 >>= fun _ -> m2
let inline (<$>)      = E.fmap
let inline (<*>)      = E.app


type typing_decl =
  | TDsym  of core_base_type
  | TDfun  of core_base_type * list core_base_type
  | TDproc of core_base_type * list core_base_type


type typing_env = <|
  decls: map name typing_decl; (* (either core_base_type (core_base_type * list core_base_type)) *)
  labs: map Symbol.sym (core_base_type * list core_base_type)
|>

val empty_env: typing_env
let empty_env =
  <| decls= Map.empty; labs= Map.empty |>

let singleton_tdecl_env nm tdecl =
  <| decls= Map.singleton nm tdecl; labs= Map.empty |>

let env_union env1 env2 =
  <| decls= Map.(union) env1.decls env2.decls; labs= Map.(union) env1.labs env2.labs |>

let env_unions envs =
  List.foldl env_union empty_env envs

let insert_tdecl nm decl env =
  <| env with decls= Map.insert nm decl env.decls |>

val is_storable: core_base_type -> bool
let is_storable = function
  | BTy_unit ->
      false
  | BTy_boolean ->
      false
  | BTy_ctype ->
      false
  | BTy_list _ ->
      false
  | BTy_tuple _ ->
      false
  | BTy_object oTy ->
      false (* should this be true? *)
  | BTy_loaded oTy ->
      true
  | BTy_storable ->
      true
end


val is_inferred_storable: maybe core_base_type -> bool
let is_inferred_storable = function
  | Just bty -> is_storable bty
  | Nothing -> false
end

(* NOTE: not commutative any more *)
val guard_match: Loc.t -> string -> core_base_type -> core_base_type -> E.eff unit
let guard_match loc str bTy1 bTy2 =
  E.guard (if bTy1 = BTy_storable then is_storable bTy2 else bTy1 = bTy2) loc (Mismatch str bTy1 bTy2)
