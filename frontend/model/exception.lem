open import List

type exceptM 'a 'msg =
  | Result of 'a
  | Exception of 'msg

declare ocaml target_rep type exceptM = `Stdlib.result`
declare ocaml target_rep function Result = `Stdlib.Ok`
declare ocaml target_rep function Exception = `Stdlib.Error`

val return: forall 'a 'msg. 'a -> exceptM 'a 'msg
val bind: forall 'a 'b 'msg.
  exceptM 'a 'msg -> ('a -> exceptM 'b 'msg) ->
  exceptM 'b 'msg
val fail: forall 'a 'msg. 'msg -> exceptM 'a 'msg

declare ocaml target_rep function return = `Result.ok`
declare ocaml target_rep function bind = `Result.bind`
declare ocaml target_rep function fail = `Result.error`


val except_fmap: forall 'a 'b 'msg. ('a -> 'b) -> exceptM 'a 'msg -> exceptM 'b 'msg
let except_fmap f m = bind m (fun z -> return (f z))


val app: forall 'a 'b 'msg. exceptM ('a -> 'b) 'msg -> exceptM 'a 'msg -> exceptM 'b 'msg
let inline app mf m = bind mf (fun f -> except_fmap f m)

val except_mapM: forall 'a 'b 'msg. ('a -> exceptM 'b 'msg) -> list 'a -> exceptM (list 'b) 'msg
let except_mapM f xs =
  List.foldr
    (fun m ms' ->
      bind m (fun x ->
      bind ms' (fun xs ->
      return (x::xs)))
    ) (return [])
  (List.map f xs)

val     except_foldlM: forall 'a 'b 'msg. ('a -> 'b -> exceptM 'a 'msg) -> 'a -> list 'b -> exceptM 'a 'msg
let rec except_foldlM f a = function
  | [] ->
      return a
  | x::xs ->
      bind (f a x) (fun z -> except_foldlM f z xs)
end


let bind_exception m k =
  match m with
    | Result a -> Result a
    | Exception s -> k s
  end


(* HACK: the indirection is for the hand-written OCaml code *)
let inline fmap = except_fmap
let inline mapM = except_mapM
